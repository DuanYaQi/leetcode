# 数论



https://blog.csdn.net/qq_44013342/article/details/88023526#t9



---

## 1979. 最大公约数

欧几里得算法，即辗转相除法
$$
gcd(a,b)=gcd(b,a \operatorname{mod} b).
$$


```c++
int gcd(int a, int b) {
        if (b == 0) return a;

        return gcd(b, a % b);
    }


int findGCD(vector<int>& nums) {
    int maxn = *max_element(nums.begin(), nums.end());
    int minn = *min_element(nums.begin(), nums.end());

    return gcd(maxn, minn);
}
```

时间复杂度：$O(n + \log M)$，其中 n 为 $\textit{nums}$ 的长度，$M$ 为 $\textit{nums}$ 的最大值。遍历数组寻找最大值与最小值的时间复杂度为 $O(n)$，计算最大公约数的时间复杂度为 $O(\log M)$。

空间复杂度：O(1)O(1)。





---

## 最小公倍数

```c++
int lcm(int a, int b){
    int g = gcd(a, b);
    return a * b / g;
}
```



















---

## 62.不同路径

一共m,n的话,无论怎么走,走到终点都需要 (m - 1) + (n - 1) 步。

其中一定有 m - 1 步是要向下走的，但不用管什么时候向下走。

那么有几种走法呢？ 可以转化为，给你 m + n - 2 个不同的数，随便取 m - 1 个数，有几种取法。

**组合问题**
$$
C_{m+n-2}^{m-1}
$$


求组合的时候,要防止两个int相乘溢出！所以不能把算式的分子都算出来,分母都算出来再做除法。

```c++
int main(int m, int n) {
    int numberator = 1, denominator = 1;
    int count = m - 1;
    int t = m + n - 2;
    
    while (count--)
        numberator *= (t--);
    
    for (int i = 1; i <= m-1; ++i)
        denominator *= i;
    
    return numberator / denominator;
}
```

需要在计算分子的时候,不断除以分母,代码如下:

```c++
int main(int m, int n) {
    int numberator = 1, denominator = 1;
    int count = m - 1;
    int t = m + n - 2;
    
    while (count--) {
        numberator *= (t--);
    
        while (denominator != 0 && numerator % denominator == 0) {
            numberator /= denominator;
            denominator--;
        }
    }       
    
    return numberator;
}
```

时间复杂度:O(m)
空间复杂度:O(1)





---

## 48. 旋转图像

用翻转代替旋转

我们还可以另辟蹊径，用翻转操作代替旋转操作。我们还是以题目中的示例二

$$
\begin{bmatrix} 5 & 1 & 9 & 11 \\ 2 & 4 & 8 & 10 \\ 13 & 3 & 6 & 7 \\ 15 & 14 & 12 & 16 \end{bmatrix}
$$


作为例子，先将其通过水平轴翻转得到：

$$
\begin{bmatrix} 5 & 1 & 9 & 11 \\ 2 & 4 & 8 & 10 \\ 13 & 3 & 6 & 7 \\ 15 & 14 & 12 & 16 \end{bmatrix} \xRightarrow[]{水平翻转} \begin{bmatrix} 15 & 14 & 12 & 16 \\ 13 & 3 & 6 & 7 \\ 2 & 4 & 8 & 10 \\ 5 & 1 & 9 & 11 \end{bmatrix}
$$
再根据主对角线翻转得到：
$$
\begin{bmatrix} 15 & 14 & 12 & 16 \\ 13 & 3 & 6 & 7 \\ 2 & 4 & 8 & 10 \\ 5 & 1 & 9 & 11 \end{bmatrix} \xRightarrow[]{主对角线翻转} \begin{bmatrix} 15 & 13 & 2 & 5 \\ 14 & 3 & 4 & 1 \\ 12 & 6 & 8 & 9 \\ 16 & 7 & 10 & 11 \end{bmatrix}
$$
就得到了答案。这是为什么呢？对于水平轴翻转而言，我们只需要枚举矩阵上半部分的元素，和下半部分的元素进行交换，即

$$
\textit{matrix}[\textit{row}][\textit{col}] \xRightarrow[]{水平轴翻转}\textit{matrix}[n - \textit{row} - 1][\textit{col}]
$$
对于主对角线翻转而言，我们只需要枚举对角线左侧的元素，和右侧的元素进行交换，即

$$
\textit{matrix}[\textit{row}][\textit{col}] \xRightarrow[]{主对角线翻转} \textit{matrix}[\textit{col}][\textit{row}]
$$


将它们联立即可得到：

$$
\begin{aligned} \textit{matrix}[\textit{row}][\textit{col}] & \xRightarrow[]{水平轴翻转} \textit{matrix}[n - \textit{row} - 1][\textit{col}] \\ &\xRightarrow[]{主对角线翻转} \textit{matrix}[\textit{col}][n - \textit{row} - 1] \end{aligned}
$$


```c++
void rotate(vector<vector<int>>& matrix) {
    int row = matrix.size();

    for (int i = 0; i < row / 2; ++i) {
        for (int j = 0; j < row; ++j) {
            swap(matrix[i][j], matrix[row - i - 1][j]);
        }
    }

    for (int i = 0; i < row; ++i) {
        for (int j = i + 1; j < row; ++j) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
}
```



---

## 223. 矩形面积

两个单独的矩阵面积 - 重复的面积，注意要判断重复部分的高，负值表示不重叠。

```c++
int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
    int s1 = (ax2 - ax1) * (ay2 - ay1);
    int s2 = (bx2 - bx1) * (by2 - by1);

    int overlapWidth = min(ax2, bx2) - max(ax1, bx1), overlapHeight = min(ay2, by2) - max(ay1, by1);

    int coverArea = max(overlapWidth, 0) * max(overlapHeight, 0);


    return s1 + s2 - coverArea;
}
```



---

## 50. Pow(x, n)

快速幂本质是分治，当 n 为负数时，可以计算正数，再取倒数。



如果我们要计算 $x^{64}$，我们可以按照：
$$
x→x^2
 →x^4
 →x^8
 →x^{16}
 →x^{32}
 →x^{64}
$$
的顺序，从 x 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 $x^{64}$ 的值，而不需要对 x 乘 63 次 x。



如果我们要计算 $x^{77}$ ，我们可以按照：

$$
x \to x^2 \to x^4 \to x^9 \to x^{19} \to x^{38} \to x^{77}
$$
的顺序，在 $x \to x^2，x^2 \to x^4，x^{19} \to x^{38}$ 这些步骤中，我们直接把上一次的结果进行平方，而在 $x^4 \to x^9，x^9 \to x^{19}，x^{38} \to x^{77}$，这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 x。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 x。但如果我们从右往左看，分治的思想就十分明显了：

- 当我们要计算 $x^n$  时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$，其中 $\lfloor a \rfloor$ 表示对 a 进行下取整；

- 根据递归计算的结果，如果 $n$ 为偶数，那么 $x^n = y^2$ ；如果 n 为奇数，那么 $x^n = y^2 \times x$；

- 递归的边界为 $n = 0$，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 $O(\log n)$，算法可以在很快的时间内得到结果。

```c++
double quickMul(double x, long long N) {
    if (N == 0) {
        return 1.0;
    }
    double y = quickMul(x, N / 2);
    return N % 2 == 0 ? y * y : y * y * x;
}

double myPow(double x, int n) {
    long long N = n;
    return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, N);
}
```



时间复杂度：$O(\log n)$，即为递归的层数。

空间复杂度：$O(\log n)$，即为递归的层数。这是由于递归的函数调用会使用栈空间。



由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 x。但我们不妨找一找规律，看看哪些地方额外乘了 x，并且它们对答案产生了什么影响。



我们还是以 $x^{77}$  作为例子：
$$
x \to x^2 \to x^4 \to^+ x^9 \to^+ x^{19} \to x^{38} \to^+ x^{77}
$$

并且把需要额外乘 x 的步骤打上了 + 标记。可以发现：

$x^{38} \to^+ x^{77}$ 中额外乘的 x 在 $x^{77}$ 中贡献了 $x$；

$x^9 \to^+ x^{19}$  中额外乘的 x 在之后被平方了 2 次，因此在 $x^{77}$ 中贡献了 $x^{2^2} = x^4$ ；

$x^4 \to^+ x^9$ 中额外乘的 x 在之后被平方了 3 次，因此在 $x^{77}$ 中贡献了 $x^{2^3} = x^8$ ；

最初的 x 在之后被平方了 6 次，因此在 $x^{77}$ 中贡献了 $x^{2^6} = x^{64}$ 。



我们把这些贡献相乘，$x \times x^4 \times x^8 \times x^{64}$,  恰好等于 $x^{77}$ 。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 xx 在之后都会被平方若干次。而这些指数 1，4，8 和 64，恰好就对应了 77 的二进制表示 $(1001101)_2$ 中的每个 11！

因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 nn 的二进制拆分为

$$
n = 2^{i_0} + 2^{i_1} + \cdots + 2^{i_k}
$$

那么

$$
x^n = x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}
$$
这样以来，我们从 x 开始不断地进行平方，得到 $x^2, x^4, x^8, x^{16}, \cdots$ ，如果 n 的第 k 个（从右往左，从 0 开始计数）二进制位为 1，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。

```c++
double quickMul(double x, long long N) {
    double ans = 1.0;
    // 贡献的初始值为 x
    double x_contribute = x;
    // 在对 N 进行二进制拆分的同时计算答案
    while (N > 0) {
        if (N % 2 == 1) {
            // 如果 N 二进制表示的最低位为 1，那么需要计入贡献
            ans *= x_contribute;
        }
        // 将贡献不断地平方
        x_contribute *= x_contribute;
        // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
        N /= 2;
    }
    return ans;
}

double myPow(double x, int n) {
    long long N = n;
    return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
}
```



- 时间复杂度：$O(\log n)$，即为对 n 进行二进制拆分的时间复杂度。
- 空间复杂度：$O(1)$。





----

# CS

## 1. 字典序

**字典序（dictionary order）**，又称 **字母序（alphabetical order）**

原意是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意**字符串**的**大小**关系。



英文中的 **字母表（Alphabet）** 按照如下的顺序排列：

ABCDEFG HIJKLMN OPQRST UVWXYZ

abcdefg hijklmn opqrst uvwxyz



大小关系取决于两个字符串**从左到右第一个不同字符的 ASCII 值的大小**关系



都提供了比较两个字符串大小的方法，比较的实际上就是两个字符串的字典序。例如在 C++  中：

```c++
cout << ("ah1x" < "ahb") << endl; //true
```



**字典序算法**





---

## 2. int类型在内存中的存储方式

int类型表示带有符号的整型，而unsigned int类型为无符号的整型。

|   类型名称   | 占字节数 |       取值范围        |
| :----------: | :------: | :-------------------: |
|     int      |    4B    | $-2^{31}\sim2^{31}-1$ |
| unsigned int |    4B    |   $0 \sim 2^{32}-1$   |



**1、占用的比特位数量**

在32位操作系统下，两者都是占用4个字节，每个字节有8个比特位，因此有32个0-1的二进制位数。两者的不同在于，int类型有正负号（±）的存在，需要比unsigned int类型多消耗一个位数。



**2、符号的表示方法**

在所有被int类型占用的比特位中，**左起第一个位**（即**最高位**）就是**符号位**。int类型的符号位上，**0表示正数**，**1表示负数**。在32位操作系统下，其余**后面31位是数值位**。



**3、数字0的表示方法**

按照上面提到的符号，我们有了两种0的表示方法，即 “+0” 和 “-0”。

实际上，在32位系统下int类型中，我们计算机已经强行规定了这种情况，数字0采用 “+0” 的表示方法，即0000000000000000 00000000；而 “**-0**” 这个特殊的数字被定义为了$-2^{31}$。

因此我们看到32位系统下int类型的取值范围中，负数部分比正数部分多了一个数字，正数的最大取值是 $2^{31}-1$，而负数的最小取值是 $-2^{31}$。**正数部分之所以要减去 1，是因为被数字 0 占用了 “+0”**，而负数部分不需要用来表示 0，因此原本的 “-0” 就用来表示 $-2^{31}$ 这个数字。



按照上面的理解方式，int类型的数字“-1”，在内存中32个比特位上应该是这样子的：10000000 00000000 00000001，左边第一个1表示负号，后面31位表示数值部分“1”。实际情况并不是这样。这里就需要引入“补码”这个概念了。



---

### 原码（true form）

原码，是计算机中一种对数字的二进制定点表示方法。原码表示法在数值前面前面有一位符号位（即最高位为符号位），正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。

int类型数值“-1”的32位二进制就是原码，即10000000 00000000 00000001。与之对应的，正数“+1”就是00000000 00000000 00000001。

那么**为何不用原码在内存中表示数值呢**？举个例子（以8位二进制表示）

|     十进制     |   原码    |
| :------------: | :-------: |
|       1        | 0000 0001 |
|       -1       | 1000 0001 |
|  结果（原码）  | 1000 0010 |
| 结果（十进制） |    -2     |

上述结果换算成十进制为-2，这显然出错了。这是由于计算机在计算时以加法进行计算的算法更简便，**减法先转换为负数**，**再进行加法运算**。因此，**原码的符号位不能直接参与运算**。

总结：原码是有符号数的**最简单的编码方式**，便于输入输出，但作为代码加减运算时较为复杂，故计算机一般不采用这种编码方式存储符号数。



---

### 反码（ones' complement）

首先我们来了解下反码表示法的规定：“**正数的反码与其原码相同**；**负数的反码是对其原码逐位取反**，但**符号位除外**。”

①  对于正数和“+0”而言，其原码本身就是反码，例如 8位二进制“+1”，其原码与反码都是00000001；

②  对于负数和“-0”而言，符号位与原码中一样，保持不变，其余位数逐位取反，1换成0,0换成1，例如 “-1”，其8位二进制原码是10000001，其反码是1111 1110；

那么是否可以正常运算了？举个三个例子：

例一：1+2=3（以8位二进制表示）

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       2        | 0000 0010 | 0000 0010 |
|  结果（反码）  |           | 0000 0011 |
|  结果（原码）  |           | 0000 0011 |
| 结果（十进制） |           |     3     |



例二：1+（-2）=-1

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       -2       | 1000 0010 | 1111 1101 |
|  结果（反码）  |           | 1111 1110 |
|  结果（原码）  |           | 1000 0001 |
| 结果（十进制） |           |    -1     |



例三：1+（-1）=0

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       -1       | 1000 0001 | 1111 1110 |
|  结果（反码）  |           | 1111 1111 |
|  结果（原码）  |           | 1000 0000 |
| 结果（十进制） |           |    -0     |

计算结果为-0 (表示为 $-2^{7}$)，问题来了，由于-0的存在，使得二进制与十进制的互换不再是一一对应的关系。

总结：由于-0这个问题的存在，会使得计算机需要增加额外的物理硬件配合运算，所以在计算机发展的早期就已经抛弃了使用反码储存数据。



---

### 补码

补码正是基于反码的**“-0”**问题诞生的，可以解决这个问题。

补码的计算方法是：**正数和+0**的补码是其**原码**，**负数**则先计算其反码，然后**反码加上1**，得到补码。

补码换算为原码的过程中，如果补码是**正数或者+0**的补码，则其原码就是**补码本身**；如果补码是负数或者-0的补码，则其原码的计算方法是，先将补码**减掉1**，得到反码，再将**反码取反**，得到原码。



**例一：1+（-1）=0**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       -1       | 1000 0001 | 1111 1110 | 1111 1111 |
|  结果（补码）  |           |           | 0000 0000 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           | 0000 0000 |
| 结果（十进制） |           |           |    +0     |

计算结果正确，+0即是数字0的唯一表示。



**例二：1+2=3**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       2        | 0000 0010 | 0000 0010 | 0000 0010 |
|  结果（补码）  |           |           | 0000 0011 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           | 0000 0011 |
| 结果（十进制） |           |           |    +3     |



**例三：1+（-2）=-1**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       -2       | 1000 0010 | 1111 1101 | 1111 1110 |
|  结果（补码）  |           |           | 1111 1111 |
|  结果（反码）  |           |           | 1111 1110 |
|  结果（原码）  |           |           | 1000 0001 |
| 结果（十进制） |           |           |    -1     |







**例四：（-1）+（-127）=-128**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       -1       | 1000 0001 | 1111 1110 | 1111 1111 |
|      -127      | 1111 1111 | 1000 0000 | 1000 0001 |
|  结果（补码）  |           |           | 1000 0000 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           |           |
| 结果（十进制） |           |           |   -128    |



我们知道8位二进制的符号数的取值范围是(-2^7)～(２^7-1),即-128～127。

由于**补码1000 0000**具有特殊性，计算机在编写底层算法时，将其规定为该取值范围中的最小数-128，其值与（-1）+(-127)的计算结果正好符合。

补充一点，**8位二进制补码1000 0000没有对应的反码和原码，其他位数的二进制补码与此类似**。



即**int类型在内存中，以补码的形式存储**。

而且我们还知道了为何int类型的取值范围中负数的最小值的绝对值比正数的最大值大1的原因，即-2^31的补码是10000000 00000000 00000000 00000000，原本-0的位置被-2^31取代了。





---

## 146. LRU（最近最少使用）

缓存淘汰策略

计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。

LRU，Least Recently Used，认为最近使用过的数据都是有用的，很久都没用过的数据应该是无用的，内存满了就优先删除很久没用过的数据。



首先接受一个 capacity 参数作为缓存的最大容量，实现两个 API，一个是









## LFU



## 进制转换



---

## 位图









---

## 大数相加



---

## 大数相乘



---

## 浮点数相乘



























