# 数论



https://blog.csdn.net/qq_44013342/article/details/88023526#t9





## 62.不同路径

一共m,n的话,无论怎么走,走到终点都需要 (m - 1) + (n - 1) 步。

其中一定有 m - 1 步是要向下走的，但不用管什么时候向下走。

那么有几种走法呢？ 可以转化为，给你 m + n - 2 个不同的数，随便取 m - 1 个数，有几种取法。

**组合问题**
$$
C_{m+n-2}^{m-1}
$$


求组合的时候,要防止两个int相乘溢出！所以不能把算式的分子都算出来,分母都算出来再做除法。

```c++
int main(int m, int n) {
    int numberator = 1, denominator = 1;
    int count = m - 1;
    int t = m + n - 2;
    
    while (count--)
        numberator *= (t--);
    
    for (int i = 1; i <= m-1; ++i)
        denominator *= i;
    
    return numberator / denominator;
}
```

需要在计算分子的时候,不断除以分母,代码如下:

```c++
int main(int m, int n) {
    int numberator = 1, denominator = 1;
    int count = m - 1;
    int t = m + n - 2;
    
    while (count--) {
        numberator *= (t--);
    
        while (denominator != 0 && numerator % denominator == 0) {
            numberator /= denominator;
            denominator--;
        }
    }       
    
    return numberator;
}
```

时间复杂度:O(m)
空间复杂度:O(1)





---

# CS

## 1. 字典序

**字典序（dictionary order）**，又称 **字母序（alphabetical order）**

原意是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意**字符串**的**大小**关系。



英文中的 **字母表（Alphabet）** 按照如下的顺序排列：

ABCDEFG HIJKLMN OPQRST UVWXYZ

abcdefg hijklmn opqrst uvwxyz



大小关系取决于两个字符串**从左到右第一个不同字符的 ASCII 值的大小**关系



都提供了比较两个字符串大小的方法，比较的实际上就是两个字符串的字典序。例如在 C++  中：

```c++
cout << ("ah1x" < "ahb") << endl; //true
```



**字典序算法**





---

## 2. int类型在内存中的存储方式

int类型表示带有符号的整型，而unsigned int类型为无符号的整型。

|   类型名称   | 占字节数 |       取值范围        |
| :----------: | :------: | :-------------------: |
|     int      |    4B    | $-2^{31}\sim2^{31}-1$ |
| unsigned int |    4B    |   $0 \sim 2^{32}-1$   |



**1、占用的比特位数量**

在32位操作系统下，两者都是占用4个字节，每个字节有8个比特位，因此有32个0-1的二进制位数。两者的不同在于，int类型有正负号（±）的存在，需要比unsigned int类型多消耗一个位数。



**2、符号的表示方法**

在所有被int类型占用的比特位中，**左起第一个位**（即**最高位**）就是**符号位**。int类型的符号位上，**0表示正数**，**1表示负数**。在32位操作系统下，其余**后面31位是数值位**。



**3、数字0的表示方法**

按照上面提到的符号，我们有了两种0的表示方法，即 “+0” 和 “-0”。

实际上，在32位系统下int类型中，我们计算机已经强行规定了这种情况，数字0采用 “+0” 的表示方法，即0000000000000000 00000000；而 “**-0**” 这个特殊的数字被定义为了$-2^{31}$。

因此我们看到32位系统下int类型的取值范围中，负数部分比正数部分多了一个数字，正数的最大取值是 $2^{31}-1$，而负数的最小取值是 $-2^{31}$。**正数部分之所以要减去 1，是因为被数字 0 占用了 “+0”**，而负数部分不需要用来表示 0，因此原本的 “-0” 就用来表示 $-2^{31}$ 这个数字。



按照上面的理解方式，int类型的数字“-1”，在内存中32个比特位上应该是这样子的：10000000 00000000 00000001，左边第一个1表示负号，后面31位表示数值部分“1”。实际情况并不是这样。这里就需要引入“补码”这个概念了。



---

### 原码（true form）

原码，是计算机中一种对数字的二进制定点表示方法。原码表示法在数值前面前面有一位符号位（即最高位为符号位），正数该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。

int类型数值“-1”的32位二进制就是原码，即10000000 00000000 00000001。与之对应的，正数“+1”就是00000000 00000000 00000001。

那么**为何不用原码在内存中表示数值呢**？举个例子（以8位二进制表示）

|     十进制     |   原码    |
| :------------: | :-------: |
|       1        | 0000 0001 |
|       -1       | 1000 0001 |
|  结果（原码）  | 1000 0010 |
| 结果（十进制） |    -2     |

上述结果换算成十进制为-2，这显然出错了。这是由于计算机在计算时以加法进行计算的算法更简便，**减法先转换为负数**，**再进行加法运算**。因此，**原码的符号位不能直接参与运算**。

总结：原码是有符号数的**最简单的编码方式**，便于输入输出，但作为代码加减运算时较为复杂，故计算机一般不采用这种编码方式存储符号数。



---

### 反码（ones' complement）

首先我们来了解下反码表示法的规定：“**正数的反码与其原码相同**；**负数的反码是对其原码逐位取反**，但**符号位除外**。”

①  对于正数和“+0”而言，其原码本身就是反码，例如 8位二进制“+1”，其原码与反码都是00000001；

②  对于负数和“-0”而言，符号位与原码中一样，保持不变，其余位数逐位取反，1换成0,0换成1，例如 “-1”，其8位二进制原码是10000001，其反码是1111 1110；

那么是否可以正常运算了？举个三个例子：

例一：1+2=3（以8位二进制表示）

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       2        | 0000 0010 | 0000 0010 |
|  结果（反码）  |           | 0000 0011 |
|  结果（原码）  |           | 0000 0011 |
| 结果（十进制） |           |     3     |



例二：1+（-2）=-1

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       -2       | 1000 0010 | 1111 1101 |
|  结果（反码）  |           | 1111 1110 |
|  结果（原码）  |           | 1000 0001 |
| 结果（十进制） |           |    -1     |



例三：1+（-1）=0

|     十进制     |   原码    |   反码    |
| :------------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 |
|       -1       | 1000 0001 | 1111 1110 |
|  结果（反码）  |           | 1111 1111 |
|  结果（原码）  |           | 1000 0000 |
| 结果（十进制） |           |    -0     |

计算结果为-0 (表示为 $-2^{7}$)，问题来了，由于-0的存在，使得二进制与十进制的互换不再是一一对应的关系。

总结：由于-0这个问题的存在，会使得计算机需要增加额外的物理硬件配合运算，所以在计算机发展的早期就已经抛弃了使用反码储存数据。



---

### 补码

补码正是基于反码的**“-0”**问题诞生的，可以解决这个问题。

补码的计算方法是：**正数和+0**的补码是其**原码**，**负数**则先计算其反码，然后**反码加上1**，得到补码。

补码换算为原码的过程中，如果补码是**正数或者+0**的补码，则其原码就是**补码本身**；如果补码是负数或者-0的补码，则其原码的计算方法是，先将补码**减掉1**，得到反码，再将**反码取反**，得到原码。



**例一：1+（-1）=0**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       -1       | 1000 0001 | 1111 1110 | 1111 1111 |
|  结果（补码）  |           |           | 0000 0000 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           | 0000 0000 |
| 结果（十进制） |           |           |    +0     |

计算结果正确，+0即是数字0的唯一表示。



**例二：1+2=3**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       2        | 0000 0010 | 0000 0010 | 0000 0010 |
|  结果（补码）  |           |           | 0000 0011 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           | 0000 0011 |
| 结果（十进制） |           |           |    +3     |



**例三：1+（-2）=-1**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       1        | 0000 0001 | 0000 0001 | 0000 0001 |
|       -2       | 1000 0010 | 1111 1101 | 1111 1110 |
|  结果（补码）  |           |           | 1111 1111 |
|  结果（反码）  |           |           | 1111 1110 |
|  结果（原码）  |           |           | 1000 0001 |
| 结果（十进制） |           |           |    -1     |







**例四：（-1）+（-127）=-128**

|     十进制     |   原码    |   反码    |   补码    |
| :------------: | :-------: | :-------: | :-------: |
|       -1       | 1000 0001 | 1111 1110 | 1111 1111 |
|      -127      | 1111 1111 | 1000 0000 | 1000 0001 |
|  结果（补码）  |           |           | 1000 0000 |
|  结果（反码）  |           |           |           |
|  结果（原码）  |           |           |           |
| 结果（十进制） |           |           |   -128    |



我们知道8位二进制的符号数的取值范围是(-2^7)～(２^7-1),即-128～127。

由于**补码1000 0000**具有特殊性，计算机在编写底层算法时，将其规定为该取值范围中的最小数-128，其值与（-1）+(-127)的计算结果正好符合。

补充一点，**8位二进制补码1000 0000没有对应的反码和原码，其他位数的二进制补码与此类似**。



即**int类型在内存中，以补码的形式存储**。

而且我们还知道了为何int类型的取值范围中负数的最小值的绝对值比正数的最大值大1的原因，即-2^31的补码是10000000 00000000 00000000 00000000，原本-0的位置被-2^31取代了。

