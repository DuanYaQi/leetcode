# 字典树







## 440. 字典序的第K小数字

给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

 

```
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```



### 思路1

**什么是字典序？**

简而言之，就是**根据数字的前缀进行排序**，

比如 10 < 9，因为 10 的前缀是 1，比 9 小。再比如 112 < 12，因为 112 的前缀 11 小于 12。

这样排序下来，会**跟平常的升序排序会有非常大的不同**。先给你一个直观的感受，一个数乘 10，或者加 1，哪个大？后者会更大。

![image.png](assets/1648002954-CMuQcz-image.png)



**每一个节点都拥有 10 个孩子节点**，因为作为一个前缀 ，它后面可以接 0~9 这十个数字。而且你可以非常容易地发现，整个字典序排列也就是对**十叉树进行先序遍历**。1, 10, 100, 101, ... 11, 110 ...

回到题目的意思，我们需要**找到排在第 k 位的数**。找到他的排位，需要搞清楚三件事情:

**怎么确定一个前缀下所有子节点的个数？**
**如果第 k 个数在当前的前缀下，怎么继续往下面的子节点找？**
**如果第 k 个数不在当前的前缀，即当前的前缀比较小，如何扩大前缀，增大寻找的范围？**

接下来 ，一一拆解这些问题。



**1. 确定指定前缀下所有子节点数**

现在的任务就是给定一个前缀，返回下面子节点总数。

我们现在的思路就是用**下一个前缀的起点减去当前前缀的起点**，那么就是当前前缀下的所有子节点数总和啦。

```c++
long getCount(long prefix, long n) {	//prefix 是前缀, n 是上界
    long cur = prefix;
    long next = prefix + 1;
    long count = 0;
    
    while (cur <= n) { //不能大于上界
        count += next - cur;	//下一个前缀的起点 减去 当前前缀的起点
        cur *= 10;
        next *= 10;
        // cur 从 1 变为 10       
        // next 从 2 变为 20
        // 前缀为 1 的子节点增加10个，十叉树增加一层，变成了2层
        // 10 - 19
        
        // cur 从 10 变为 100
        // next 从 20 变为 200
        // 前缀为 10 的子节点增加了100个，十叉树增加一层，变成了3层
    	// 100-109 110-119 120-129 130-139 140-149 
        // 150-159 160-169 170-179 180-189 191-199
    }
    return count;
}
```



当然，**当 next 的值大于上界的时候，**那以这个前缀为根节点的十叉树就**不是满十叉树**，**应该到上界那里**，后面都不再有子节点。因此，`count += next - cur` 还是有些问题的，我们来修正这个问题:

```c++
count += min(n + 1, next) - cur;
```

为什么是 n+1 ,而不是 n 呢？不是 n 为上界吗？

假若现在上界 n为 12，算出以 1 为前缀的子节点数，首先 1 本身是一个节点，接下来要算下面 10，11，12，一共有 4 个子节点。

那么如果用 `min(n, next) - cur`  会怎么样？

这时候算出来会少一个，12 - 10 加上根节点，最后只有 3 个。因此我们务必要写 n+1。



**2. 第k个数在当前前缀下**

现在无非就是往子树里面去看。prefix这样处理就可以了。

```c++
prefix *= 10;
```



**3.第k个数不在当前前缀下**

说白了，当前的前缀小了嘛，我们扩大前缀。

```
prefix++;
```



**整合**

```c++
int findKthNumber(int n, int k) {
	int p = 1, prefix = 1;	//p作为一个指针，指向当前所在位置，当p=k时，就为答案
    while (p < k) {
        long count = getCount(prefix, n);
        if (p + count > k) {			// 第k个数在当前前缀下
            prefix *= 10;	
            p++; //把指针指向了第一个子节点的位置，比如11乘10后变成110，指针从11指向了110
        } else if (p + count <= k) {	// 第k个数不在当前前缀下
            prefix++;
            p += count;// 把指针指向了下一前缀的起点
        }
    }
    return prefix;   
}
```











```c++
long getCount(long prefix, long n) {
    long cur = prefix;
    long next = cur + 1;
    long count = 0;
    while (cur <= n) {
        count += min(n+1, next) - cur;
        cur  *= 10;
        next *= 10;
    }
}
```





```c++
class Solution {
public:
    long getCount(long prefix, long n) {
        long cur = prefix;
        long next = cur + 1;
        long count = 0;
        while(cur <= n) {
            count += min(n+1, next) - cur;
            cur *= 10;
            next *= 10;
        }
        return count;
    }

    int findKthNumber(int n, int k) {
        long p = 1;
        long prefix = 1;
        while(p < k) {
            long count = getCount(prefix, n);
            if (p + count > k) {
                /// 说明第k个数，在这个前缀范围里面
                prefix *= 10;
                p++;
            } else if (p+count <= k) {
                /// 说明第k个数，不在这个前缀范围里面，前缀需要扩大+1
                prefix++;
                p += count;
            }
        }
        return static_cast<int>(prefix);
    }
};
```



### 思路2

![image.png](assets/1648002954-CMuQcz-image-164835198704211.png)

当将n=12转换为字典树时候，我们可以发现字典序不过就是这颗字典树的先序遍历

> 那么要找到第5小的数，就采用先序遍历的方法
>
> 先找到1： 第1小
> 再找到10：第2小
> 再找到11：第3小
> 再找到12：第4小
> 再找到2： 第5小





**解题思路**

但是很显然将整棵树构建起来是不现实的，当 $n = 10^9$ 的时候就是上亿个节点了

不过也不用担心，因为这颗字典树是的十叉树，并且具有明显的**先序遍历递增**的特点

那么我们就可以**通过计算得到某个节点下的子树节点的总数而跳过遍历的时间**

例如下图中求1的子树节点数量：

![image.png](assets/1648002963-AFAkiX-image.png)

- 1下的第一层：最左端为10，即 `1*10`；最右端为19，即 `(1+1) * 10 - 1`，合计20-10 = 10
  - 换成 **i**：最左端为 `i*10`；最右端为 `(i + 1) * 10 - 1`
- 1下的第一层：最左端为 100，最右端为 112 (即 **n**)，而不是 200 了，合计 `112-100+1 = 13`
  - 这一层到不了 200 那么多，只能到 n

- 合计 `10+13 = 26`



```C++
int getNodes(long cur, int n) { //cur 为当前前缀 n为上界
    long next = cur + 1;
    long count = 0;
    while (cur <= n) {
        // 一次性求出下一层的节点个数和，要是没满就用n来减，要是满了就用next减
        count += 
    }
}
```





**能求出子树节点个数有什么用呢？**

如果求出**以i为根的子树节点有nodes个**

如果nodes比k少，那么这个部分都可以全部跳过，第k小的数肯定不在这些节点里，**i右移**

如果nodes比k多，那么第k小的数一定在这个里面，并是以 i 开头的数，**i下移**

因此我们可以**移动 i 指向的节点，直到跳过的节点数达到 k**



```c++
int findKthNumber (int n, int k) {
    long cur = 1;
}
```

