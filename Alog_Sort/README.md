# Sort

**通用函数及其他**

(1) 求数组长度（需要传数组，不要传数组指针）

```c++
/*  一定要注意传入的数组是否为数组指针
	如果传入的是数组指针，sizeof 后出来的值为 8
*/
template <class T>
int len(T& arr) {
    int length = (int)sizeof(arr) / sizeof(arr[0]);
    return length;
}
```





# 非线性时间

## 归并排序 - 归并









---

## 快速排序 - 比较







---

## 冒泡排序 - 比较







---

## 插入排序 - 插入







---

## 希尔排序 - 插入





## 选择排序 - 选择











---

# 线性时间

## 堆排序 - 选择





---

## 基数排序









## 计数排序





---

# 总结

当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。



会问面试者知道哪些排序算法，选一个自己熟悉排序算法。讲下它的主要特点，比如**时间复杂度 / 稳定性** 这些

如果继续，一般会把重点放在 **快速排序** 和 **堆排**，进一步可能会要求手写实现。然后会讨论下在**输入是特定序列的情况下，当前的算法有什么缺点或优点**。



**基数排序**这类算法，会问下一些偏**理论**的问题，比如比较排序算法的**下界**是多少，为什么基数排序可以突破这个下界。



**『算法导论』的第二部分 『排序和顺序统计学』**，是很好的排序算法基础。几十页，认真看。

**『[编程珠玑](https://www.zhihu.com/search?q=编程珠玑&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A286065483})』第十一章 『排序』**，对快速排序做了细节性的讨论。

![img](assets/v2-c6acea068837aead97877f8fdf4a750f_720w.jpg)



![img](assets/v2-35c344cf0bac4720e57df56df9f23e86_720w.jpg)





![img](assets/v2-5e56c508652d1f3da2e95b209c8d572b_720w.jpg)



![八大经典排序算法原理（C++实现）](assets/v2-0650b3fe6427619f1d2390f94d52c4f6_1440w.jpg)





![img](assets/849589-20180402133438219-1946132192.png)





![img](assets/v2-2477e51d53090f1dfa44e91d1bfbc116_720w.jpg)

> **n指数据规模；**
>
> **k指“桶”的个数；**
>
> **In-place指占用常数内存，不占用额外内存；**
>
> **Out-place指占用额外内存**





---

# 内部非内部

![img](assets/v2-5ab3d2cfc00f3d4e61f0a7d9c1103f9c_720w.jpg)

内排序：所有排序操作都在**内存中**完成；

外排序：由于数据太大，因此把数据放在磁盘中，而排序**通过磁盘和内存**的数据传输才能进行；





---

# 比较非比较

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 



![img](assets/849589-20190306165258970-1789860540.png)



常见的**快速排序、归并排序、堆排序、冒泡排序**等属于**比较排序**。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。

- 在**冒泡排序**之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。
- 在**归并排序、快速排序**之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。

比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。



**计数排序、基数排序、桶排序**则属于**非比较排序**。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。

非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。



---

# 稳定非稳定

![排序算法的稳定性](assets/v2-0872ff222124611b3403a888be76c2b9_1440w.jpg)

假定在待排序的记录序列中，存在多个具有**相同的关键字**的记录，若**经过排序**，这些记录的**相对次序保持不变**，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。

排序算法是否为稳定的是由具体算法决定的，**不稳定的算法在某种条件下可以变为稳定的算法**，而**稳定的算法在某种条件下也可以变为不稳定的算法**。



常见算法的稳定性（要记住）

**不稳定排序算法**

堆排序、快速排序、希尔排序、直接选择排序

**稳定排序算法**

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序



---