# æ ‘/äºŒå‰æ ‘

## 1. ç§ç±»

### 1.1. æ»¡äºŒå‰æ ‘

å›½å†…å®šä¹‰ï¼šé™¤æœ€åä¸€å±‚æ— ä»»ä½•å­èŠ‚ç‚¹å¤–ï¼Œæ¯ä¸€å±‚ä¸Šçš„æ‰€æœ‰ç»“ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­ç»“ç‚¹çš„äºŒå‰æ ‘ã€‚æ»¡äºŒå‰æ ‘å¤–è§‚ä¸Šæ˜¯ä¸€ä¸ª**ä¸‰è§’å½¢**ã€‚

å›½å¤–å®šä¹‰ï¼šå¦‚æœä¸€æ£µæ ‘åªæœ‰**åº¦**ä¸º **0** çš„ **2** çš„ç»“ç‚¹ï¼Œå¹¶ä¸”åº¦ä¸º 0 çš„ç»“ç‚¹åœ¨åŒä¸€å±‚ä¸Šï¼Œåˆ™è¿™æ£µäºŒå‰æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚



### 1.2. å®Œå…¨äºŒå‰æ ‘

é™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡è¢«å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€**å·¦**è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬hå±‚ï¼Œåˆ™è¯¥å±‚èŠ‚ç‚¹æ•°èŒƒå›´ä¸º  $1$ ~ $2^h-1$ ä¸ªã€‚

![1615869609545](assets/1615869609545.png)

ä¼˜å…ˆçº§é˜Ÿåˆ—èµ·å§‹æ˜¯ä¸€ä¸ªå †ï¼Œå †å°±æ˜¯ä¸€é¢—å®Œå…¨äºŒå‰æ ‘ï¼ŒåŒæ—¶ä¿è¯çˆ¶å­èŠ‚ç‚¹çš„**é¡ºåº**å…³ç³»ã€‚



### 1.3. äºŒå‰æœç´¢æ ‘

BST  Binary Search Tree

äºŒå‰æœç´¢æ ‘æ˜¯æœ‰**æ•°å€¼**çš„ï¼Œä¸”æ˜¯ä¸€ä¸ª**æœ‰åº**æ ‘ã€‚

- è‹¥å…¶å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼›
- è‹¥å…¶å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼›
- å…¶å·¦å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æ’åºæ ‘ã€‚

![1615869776230](assets/1615869776230.png)

ä¸Šä¸¤æ£µéƒ½æ˜¯äºŒå‰æœç´¢æ ‘



ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œé‚£ä¹ˆ**ä¸­åºéå†çš„ç»“æœå°±ä¼šæ˜¯ä¸€ä¸ªé€’å¢åºåˆ—**ï¼Œå› æ­¤åªéœ€è¦åˆ¤æ–­æ¯æ¬¡èŠ‚ç‚¹ä¸Šçš„å€¼æ˜¯å¦å¤§äºå‰ä¸€ä¸ªå€¼ï¼Œå¦‚æœå¤§äºå°±ç»§ç»­å‘åéå†ï¼Œç›´åˆ°æœ€åä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œå¦‚æœå‡ºç°åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼å°äºå‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°±ç›´æ¥è¿”å›falseã€‚





### 1.4. å¹³è¡¡äºŒå‰æœç´¢æ ‘

AVLï¼ˆAdelson-Velsky and Landisï¼‰æ ‘ï¼Œå®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–å®ƒçš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€é¢—å¹³è¡¡äºŒå‰æ ‘ã€‚

![1615869887421](assets/1615869887421.png)

â€‹	æœ€åä¸€æ£µé«˜åº¦å·®è¶…è¿‡1.



C++ä¸­**mapã€setã€multimapï¼Œmultiset**çš„åº•å±‚å®ç°éƒ½æ˜¯**å¹³è¡¡äºŒå‰æœç´¢æ ‘**ã€‚æ‰€æœ‰mapã€setçš„å¢åˆ æ“ä½œæ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ `log(n)`ï¼Œç‰¹åˆ«çš„**unordered_mapã€unordered_set**åº•å±‚å®ç°ä¸º**å“ˆå¸Œè¡¨**ã€‚



### 1.5. Complete/Perfect/Full

å›½å¤–å®šä¹‰çš„**æ»¡**äºŒå‰æ ‘ Full Binary Tree æ˜¯æŒ‡ä¸€æ£µäºŒå‰æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹è¦ä¹ˆ**æ²¡æœ‰å­©å­èŠ‚ç‚¹**ï¼Œè¦ä¹ˆæœ‰**ä¸¤ä¸ªå­©å­èŠ‚ç‚¹**ï¼›

**å®Œå…¨**äºŒå‰æ ‘å¯¹åº” Complete Binary Treeï¼›æœ‰**é¡ºåº**é™åˆ¶ã€‚

**å›½å†…**å®šä¹‰çš„**æ»¡**äºŒå‰æ ‘ Perfect Binary Treeæ˜¯æŒ‡é™¤æœ€åä¸€å±‚æ— ä»»ä½•å­èŠ‚ç‚¹å¤–ï¼Œæ¯ä¸€å±‚ä¸Šçš„æ‰€æœ‰ç»“ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­ç»“ç‚¹çš„äºŒå‰æ ‘ã€‚

![img](assets/trees.png)



---

## 2. å­˜å‚¨æ–¹å¼

é“¾å¼å­˜å‚¨ï¼ŒæŒ‡é’ˆï¼Œä¸è¿ç»­

é¡ºåºå­˜å‚¨ï¼Œæ•°ç»„ï¼Œè¿ç»­	çˆ¶èŠ‚ç‚¹æ•°ç»„ä¸‹æ ‡ä¸º `i`ï¼Œ å·¦å­©å­ä¸º`i*2+1` ï¼Œå³å­©å­ä¸º `i*2 + 2`

```c++
for (int i = 0; i < N; ++i) {
    cin >> tree1[i];
}

for (int i = 0; i < N; ++i) {
    cin >> tree2[i];
}

TreeNode* root = new TreeNode();
root = traverse(tree1, 0, N - 1, tree2, 0, N - 1);


TreeNode* traverse(vector<int> &inorder, int inStart, int inEnd, 
            vector<int> &postorder, int postStart, int postEnd) {
    
    if (inStart > inEnd || postStart > postEnd) {
        return nullptr;
    }

    int midIdx = -1;
    int midV = postorder[postEnd];
    for (int i = inStart; i <= inEnd; ++i) {
        if (inorder[i] == midV) {
            midIdx = i;
            break;
        }
    }

    TreeNode* root = new TreeNode(midV);

    root->left = traverse(inorder, inStart, midIdx-1,
            postorder, postStart, postStart + midIdx - inStart - 1);
    root->right = traverse(inorder, midIdx + 1, inEnd,
            postorder, postStart + midIdx - inStart, postEnd - 1);
    return root;
}
```





----

## 3. å®šä¹‰

```c++
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x), left(NULL), right(NULL) {}
};
```



---

## 4. éå†æ–¹å¼

æ·±åº¦ä¼˜å…ˆéå†ï¼šå…ˆå¾€æ·±èµ°ï¼Œé‡åˆ°å¶å­èŠ‚ç‚¹å†å¾€å›èµ°

- å‰åºéå† é€’å½’ã€è¿­ä»£   ä¸­å·¦å³
- ä¸­åºéå† é€’å½’ã€è¿­ä»£   å·¦ä¸­å³
- ååºéå† é€’å½’ã€è¿­ä»£   å·¦å³ä¸­ï¼ˆéœ€è¦çŸ¥é“å­æ ‘ä¿¡æ¯çš„ä¸€å®šæ˜¯ååºéå†ï¼‰

å¹¿åº¦ä¼˜å…ˆéå†ï¼šä¸€å±‚ä¸€å±‚çš„éå†.

- å±‚æ¬¡éå† è¿­ä»£



---

### 4.1. é€’å½’éå†

é€’å½’ä¸‰è¦ç´ 

1. **ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼**ï¼šç¡®å®šå“ªäº›å‚æ•°æ˜¯é€’å½’è¿‡ç¨‹ä¸­éœ€è¦å¤„ç†çš„ï¼Œå°±åœ¨å‡½æ•°ä¸­åŠ æ­¤å‚æ•°ã€‚å¹¶ä¸”è¿˜è¦æ˜ç¡®æ¯æ¬¡é€’å½’çš„è¿”å›å€¼ï¼Œç¡®å®šé€’å½’å‡½æ•°è¿”å›ç±»å‹ã€‚
2. **ç¡®å®šç»ˆæ­¢æ¡ä»¶**ï¼šé˜²æ­¢æ ˆæº¢å‡ºã€‚
3. **ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘**ï¼šç¡®å®šæ¯å±‚é€’å½’è¦å¤„ç†çš„ä¿¡æ¯ã€‚



ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼š

[94. Binary Tree Inorder Traversal](94+inorderTraversal.cpp)

[144. Binary Tree Preorder Traversal](144+preorderTraversal.cpp)

[145. Binary Tree Postorder Traversal](145+postorderTraversal.cpp)

```c++
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    
    
    traversal(cur->left, vec); // å·¦
    vec.push_back(cur->val); // ä¸­
    traversal(cur->right, vec); // å³
}

void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    
    vec.push_back(cur->val); // ä¸­
    traversal(cur->left, vec); // å·¦
    traversal(cur->right, vec); // å³
}


void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    
    traversal(cur->left, vec); // å·¦
    traversal(cur->right, vec); // å³
    vec.push_back(cur->val); // ä¸­
}

```



---

### 4.2. è¿­ä»£éå†

é€’å½’çš„å®ç°ï¼šæ¯ä¸€æ¬¡é€’å½’ç¬¬è°ƒç”¨éƒ½ä¼šæŠŠå‡½æ•°çš„å±€éƒ¨å˜é‡ã€å‚æ•°å€¼å’Œè¿”å›åœ°å€ç­‰**å‹å…¥è°ƒç”¨æ ˆ**ä¸­ï¼Œé€’å½’è¿”å›æ—¶ï¼Œä»æ ˆé¡¶å¼¹å‡ºä¸Šä¸€æ¬¡é€’å½’çš„å„é¡¹å‚æ•°ã€‚

**æ³¨æ„ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆ**

#### å‰åº

```c++
vector<int> preorderTraversal (TreeNode* root) {
  	stack<TreeNode*> st;
    vector<int> res;
    if (!root) return res;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        res.push_back(node->value);
        if (node->right) st.push(node->right); //ç©ºèŠ‚ç‚¹ä¸å¦‚æ ˆ 
        if (node->left)  st.push(node->left);  //æ ˆå…ˆè¿›åå‡º æ‰€æœ‰æœ€åå‹å·¦å­æ ‘
    }
    return res;
}
```

#### ä¸­åº 

å€ŸåŠ©æŒ‡é’ˆçš„éå†æ¥å¸®åŠ©è®¿é—®èŠ‚ç‚¹ï¼Œæ ˆç”¨æ¥å¤„ç†èŠ‚ç‚¹ä¸Šçš„å…ƒç´ ã€‚

```c++
vector<int> inorderTraversal (TreeNode* root) {
  	stack<TreeNode*> st;
    vector<int> res;
	TreeNode* cur = root;
    while ( !cur || !st.empty()) {
		if (!cur) {
        	st.push(cur);
            cur = cur->left;
        } else {
            cur = st.top();
            st.pop();
            res.push_back(cur->val);
            cur = cur->right;
        }
    }
    return res;
}
```

#### ååº

```c++
vector<int> PostorderTraversal (TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> res;
    if (!root) return res;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();
        res.push_back(node->value);
        if (node->left)  st.push(node->left);  //æ ˆå…ˆè¿›åå‡º æ‰€æœ‰æœ€åå‹å·¦å­æ ‘
        if (node->right) st.push(node->right); //ç©ºèŠ‚ç‚¹ä¸å¦‚æ ˆ 
    }
    reverse(res.begin(), res.end());//åè½¬ å·¦å³ä¸­
    return res;
}
```

è¿™æ ·çš„é£æ ¼ä¸ç»Ÿä¸€ã€‚



---

### 4.3. ç»Ÿä¸€è¿­ä»£éå†

å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¸­ï¼ŒæŠŠè¦å¤„ç†çš„èŠ‚ç‚¹ä¹Ÿæ”¾å…¥æ ˆä¸­ï¼Œä½†æ˜¯åšæ ‡è®°ã€‚

å³è¦å¤„ç†çš„èŠ‚ç‚¹æ”¾å…¥æ ˆä¹‹åï¼Œ**ç´§æ¥ç€æ”¾å…¥ä¸€ä¸ªç©ºæŒ‡é’ˆä½œä¸ºæ ‡è®°**ã€‚**æ ‡è®°æ³•**

#### ä¸­åº

```c++
// å·¦ä¸­å³ å‹æ ˆä¸º å³ä¸­å·¦
vector<int> inorderTraversal(TreeNode* root) {
    vecotr<int> res;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop(); //å¼¹å‡ºï¼Œé¿å…é‡å¤æ“ä½œï¼Œå†å°†å³ä¸­å·¦èŠ‚ç‚¹æ·»åŠ åˆ°æ ˆä¸­
            if (node->right) st.push(node->right);	// æ·»åŠ å³èŠ‚ç‚¹
            st.push(node);							// æ·»åŠ ä¸­èŠ‚ç‚¹
            st.push(NULL);							// è®¿é—®è¿‡ä¸­èŠ‚ç‚¹ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¤„ç†ï¼ŒåŠ å…¥ç©ºåšæ ‡è®°
            	
            if (node->left) st.push(node->left);	// æ·»åŠ å·¦èŠ‚ç‚¹
        } else {			// é‡åˆ°ç©ºèŠ‚ç‚¹æ—¶ï¼Œå°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ”¾è¿›ç»“æœé›†
            st.pop();		
            node = st.top();
            st.pop();
            res.push_back(node->val);
        }
    }
    return res;
}
```



#### å‰åº

```c++
// ä¸­å·¦å³ å‹æ ˆä¸º å³å·¦ä¸­
vector<int> PreTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
    	TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            if (node->right) 	st.push(node->right);
            if (node->left) 	st.push(node->left);
            st.push(node); 	//æ”¾ä¸­èŠ‚ç‚¹ï¼Œ
            st.push(NULL);	//è®¿é—®è¿‡åŠ null
        } else {
            st.pop();
            node = st.top();
            st.pop();
            res.push_back(node->val);
        }
    }
    return res;
}
```



#### ååº

```c++
// å·¦å³ä¸­ å‹æ ˆä¸º ä¸­å³å·¦
vector<int> PreTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    if (root != NULL) st.push(root);
    while (!st.empty()) {
    	TreeNode* node = st.top();
        if (node != NULL) {
            /* å¯çœç•¥
            st.pop();
            st.push(node); 	//æ”¾ä¸­èŠ‚ç‚¹ï¼Œ
            */
            st.push(NULL);	//è®¿é—®è¿‡åŠ null
            if (node->right) 	st.push(node->right);
            if (node->left) 	st.push(node->left);
        } else {
            st.pop();
            node = st.top();
            st.pop();
            res.push_back(node->val);
        }
    }
    return res;
}
```



---

### 4.4. å±‚åºéå†

#### è‡ªé¡¶å‘ä¸‹

å³é€å±‚çš„ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹

éœ€è¦å€ŸåŠ©ä¸€ä¸ªè¾…åŠ©æ•°æ®ç»“æ„å³**é˜Ÿåˆ—**æ¥å®ç°ï¼Œé˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºï¼Œç¬¦åˆä¸€å±‚ä¸€å±‚**å®½åº¦ä¼˜å…ˆéå†**çš„é€»è¾‘ï¼ˆç”¨**æ ˆ**å…ˆè¿›åå‡ºæ˜¯æ¨¡æ‹Ÿ**æ·±åº¦ä¼˜å…ˆéå†**ä¹Ÿå°±æ˜¯**é€’å½’**çš„é€»è¾‘ã€‚ï¼‰

```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<vector<int>> res;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;

        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();	//æ³¨æ„è¿™ä¸ªåœ¨å¾ªç¯é‡Œ
            que.pop();
            vec.push_back(node->val);
            if (node->left)   que.push(node->left);
            if (node->right)  que.push(node->right);
        }
        res.push_back(vec);
    }
    return res;
} 
```



#### è‡ªåº•å‘ä¸Š

```c++
è‡ªé¡¶å‘ä¸‹å¤„ç†å ç›´æ¥åè½¬ 
reverse();
```



#### ä¹ é¢˜

**199. binary tree right side view** äºŒå‰æ ‘çš„å³è§†å›¾



```c++
vector<int> rightSideView(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<int> res;

    while (!que.empty()) {
        int size = que.size();

        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            if (i == size-1 ) res.push_back(node->val);
            if (node->left)   que.push(node->left);
            if (node->right)  que.push(node->right);
        }
    }
    return res;
}
```



**637. Average of Levels in Binary Tree** äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼

```c++
vector<double> averageOfLevels(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);
    vector<double> res;

    while (!que.empty()) {
        int size = que.size();
        double asum = 0;	//!!!!!!!!!!!!!æ³¨æ„æ¸…é›¶
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            asum += node->val;
            if (node->left)   que.push(node->left);
            if (node->right)  que.push(node->right);
        }
        res.push_back(double(asum/size));
    } 
    return res;
}  
```



**429. N-ary Tree Level Order Traversal**  Nå‰æ ‘çš„å±‚åºéå†

```c++
vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> res;
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            Node* node = que.front();
            vector<int> vec;
            int size = que.size();

            for (int i = 0; i < size; ++i) {
                Node* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (!node->children.empty()) {
                    int vsize = node->children.size();
                    for (int j = 0; j < vsize; ++j) {
                        que.push(node->children[j]);
                    }
                }    
            }
            res.push_back(vec);
        }
        return res;
    }
```



**515.Find Largest Value in Each Tree Row** åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

```c++
vector<int> largestValues(TreeNode* root) {
    vector<int> res;
    queue<TreeNode*> que;
    if (root != NULL) que.push(root);

    while (!que.empty()) {
        TreeNode* node = que.front();
        int size = que.size();
        int flag = 0x80000000; //INT_MIN

        for (int i = 0; i < size; ++i) {
            TreeNode* node = que.front();
            que.pop();
            flag = node->val > flag ? node->val : flag;
            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
        res.push_back(flag);
    }
    return res;
}
```



**116. Populating Next Right Pointers in Each Node** å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

```c++
Node* connect(Node* root) {
    queue<Node*> que;
    if (root != NULL) que.push(root);
    while (!que.empty()) {
        int size = que.size();
        Node* node;
        Node* prenode;

        for (int i = 0; i < size; ++i) {
            if (i == 0) {
                prenode = que.front();
                que.pop();
                node = prenode;
            } else {
                node = que.front();
                que.pop();
                prenode->next = node;
                prenode = prenode->next;
            }
            if (node->left)     que.push(node->left);
            if (node->right)    que.push(node->right);
        }
        prenode->next = NULL; 	// prenode æˆ–è€… node éƒ½å¯ä»¥
    }
    return root;
}
```





**117. Populating Next Right Pointers in Each Node II** å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II

```c++
ä¸116ä¸€æ¨¡ä¸€æ ·
```



---

## 5.  ç¿»è½¬äºŒå‰æ ‘

**226. Invert Binary Tree**

```c++
TreeNode* invertTree(TreeNode* root) {
    if (root == NULL) return root;
    TreeNode* tmp = root->right;
    root->right = root->left;
    root->left = tmp;
    // swap(root->left, root->right)
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

é’ˆå¯¹äºŒå‰æ ‘çš„é—®é¢˜ï¼Œè§£é¢˜å‰ï¼Œæƒ³æ¸…æ¥šç©¶ç«Ÿæ˜¯**å‰ä¸­åå±‚åºå“ªç§éå†**ã€‚



è¿­ä»£çš„å†™æ³•ï¼Œä¿è¯åŸæ¥çš„è¿­ä»£éå†ï¼Œåªæ˜¯æŠŠèŠ‚ç‚¹åŠ å…¥å®¹å™¨ä¹‹åï¼Œå†è¿›è¡Œswapæ›´æ¢ä½ç½®ã€‚

èŠ‚ç‚¹åŠ å…¥å®¹å™¨ï¼Œæ˜¯ä¸ºäº†åç»­ç»§ç»­éå†ã€‚



---

## #1-5. å°ç»“

**çº¢é»‘æ ‘**å°±æ˜¯ä¸€ç§**äºŒå‰å¹³è¡¡æœç´¢æ ‘**ï¼ŒC++ä¸­ `mapã€multimapã€setã€multiset` çš„åº•å±‚å®ç°æœºåˆ¶å°±æ˜¯äºŒå‰å¹³è¡¡æœç´¢æ ‘ï¼Œå†å…·ä½“å°±æ˜¯çº¢é»‘æ ‘

æ ‘çš„éå†æœ‰ä¸€ç§å¾ˆå‰å®³çš„æ–¹æ³• **morriséå†**

é€’å½’å†™æ³•ã€‚**å®é™…é¡¹ç›®å¼€å‘ä¸­ï¼Œé¿å…é€’å½’**ã€‚å› ä¸ºé¡¹ç›®ä»£ç å‚æ•°ã€è°ƒç”¨å…³ç³»éƒ½æ¯”è¾ƒå¤æ‚ï¼Œä¸å®¹æ˜“æ§åˆ¶é€’å½’æ·±åº¦ï¼Œç”šè‡³ä¼šæ ˆæº¢å‡ºã€‚

æ ˆå®ç°é€’å½’å†™æ³•ï¼ˆå³è¿­ä»£ï¼‰

**æ ˆå®ç°é€’å½’å†™æ³•ï¼ˆè¿­ä»£ç»Ÿä¸€ï¼‰**ã€‚ä¸€å®šè¦æŒæ¡å‰åä¸­åºä¸€ç§è¿­ä»£çš„å†™æ³•ï¼Œé¢è¯•å®˜çœ‹å†™å‡ºäº†é€’å½’ï¼Œä¼šè¿›ä¸€æ­¥è€ƒå¯Ÿèƒ½ä¸èƒ½å†™å‡ºç›¸åº”çš„è¿­ä»£ã€‚








---

## è¿­ä»£æ³•å’Œé€’å½’æ³•çš„åŒºåˆ«

åˆ¤æ–­æ¡ä»¶æ˜¯ç›¸åŒçš„ï¼Œè¿­ä»£æ³•æ˜¯æ‰‹åŠ¨åˆ†é…ç©ºé—´

**100.ç›¸åŒçš„æ ‘**

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<TreeNode*> que;
    que.push(p);
    que.push(q);

    while (!que.empty()) {
        TreeNode* L = que.front(); que.pop();
        TreeNode* R = que.front(); que.pop();

        if (L == nullptr && R == nullptr) continue;
        if (L == nullptr || R == nullptr || L->val != R->val) return false;

        que.push(L->left);
        que.push(R->left);
        que.push(L->right);
        que.push(R->right);
    }

    return true;

}
```



```c++
bool rec(TreeNode* L, TreeNode* R) {
    if (L == nullptr && R == nullptr) return true;

    if (L == nullptr || R == nullptr || L->val != R->val) {
        return false;
    } 

    return rec(L->left, R->left) & rec(L->right, R->right);
}

bool isSameTree(TreeNode* p, TreeNode* q) {
    return rec(p, q);
}
```







---

# äºŒå‰æ ‘çš„å±æ€§

---

## 6. å¯¹ç§°äºŒå‰æ ‘

æ¯”è¾ƒä¸¤ä¸ªå­æ ‘çš„é‡Œä¾§å’Œå¤–ä¾§çš„å…ƒç´ æ˜¯å¦ç›¸ç­‰ã€‚

**ååºéå†**ï¼Œä¸€ä¸ªæ ‘éå†é¡ºåºæ˜¯å·¦å³ä¸­ï¼Œå¦ä¸€ä¸ªæ˜¯å³å·¦ä¸­ã€‚

![image-20220225095910153](assets/image-20220225095910153.png)

å› ä¸ºè¦éå†ä¸¤æ£µæ ‘â½½ä¸”è¦**â½è¾ƒå†…ä¾§å’Œå¤–ä¾§èŠ‚ç‚¹**ï¼Œæ‰€ä»¥å‡†ç¡®çš„æ¥è¯´æ˜¯**â¼€ä¸ªæ ‘çš„éå†é¡ºåºæ˜¯å·¦å³ä¸­**ï¼Œ**â¼€ä¸ªæ ‘çš„éå†é¡ºåºæ˜¯å³å·¦ä¸­**ã€‚



**101. Symmetric Tree**

```c++
bool compare(TreeNode* left, TreeNode* right) {
    if (left == NULL && right != NULL) return false;
    else if (left != NULL && right == NULL) return false;
    else if (left == NULL && right == NULL) return true;
    else if (left->val != right->val) return false; 
    else return compare(left->left, right->right) && compare(left->right, right->left);
}

bool isSymmetric(TreeNode* root) {
    if (root == NULL) return true;
    return compare(root->left, root->right);
}
```



è¿­ä»£æ³•

```c++
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    queue<TreeNode*> que;
    que.push(root->left);
    que.push(root->right);

    while (!que.empty()) {
        TreeNode* nodeL = que.front(); que.pop();
        TreeNode* nodeR = que.front(); que.pop();

        if (nodeL == nullptr && nodeR == nullptr) continue;
        if (nodeL == nullptr || nodeR == nullptr || (nodeL->val != nodeR->val)) return false;

        que.push(nodeL->left);
        que.push(nodeR->right);
        que.push(nodeL->right);
        que.push(nodeR->left);
    }
    return true;
}
```

è¿™ä¸ªè¿­ä»£æ³•ï¼Œå…¶å®æ˜¯æŠŠ**å·¦å³ä¸¤ä¸ªâ¼¦æ ‘è¦â½è¾ƒçš„å…ƒç´ é¡ºåºæ”¾è¿›â¼€ä¸ªå®¹å™¨**ï¼Œç„¶å**æˆå¯¹æˆå¯¹çš„å–å‡ºæ¥è¿›â¾â½è¾ƒ**ï¼Œé‚£ä¹ˆå…¶å®ä½¿â½¤æ ˆä¹Ÿæ˜¯å¯ä»¥çš„ã€‚



```c++
bool isSymmetric(TreeNode* root) {
    if (root == nullptr) return true;
    stack<TreeNode*> st;
    st.push(root->left);
    st.push(root->right);

    while (!st.empty()) {
        TreeNode* nodeL = st.top(); st.pop();
        TreeNode* nodeR = st.top(); st.pop();

        if (nodeL == nullptr && nodeR == nullptr) continue;
        if (nodeL == nullptr || nodeR == nullptr || nodeL->val != nodeR->val) return false;

        st.push(nodeL->left);
        st.push(nodeR->right);
        st.push(nodeL->right);
        st.push(nodeR->left);
    }
    return true;
}
```





---

## 104. äºŒå‰æ ‘çš„æ·±åº¦

**104. Maximum Depth of Binary Tree**

æœ€â¼¤æ·±åº¦æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶â¼¦èŠ‚ç‚¹çš„æœ€â»“è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ€»æ•°ã€‚

```c++
int maxDepth(TreeNode* root) {
    if (root==NULL) return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
}
```



**111. Minimum Depth of Binary Tree**

æœ€â¼©æ·±åº¦æ˜¯ä»**æ ¹èŠ‚ç‚¹**åˆ°æœ€è¿‘**å¶â¼¦èŠ‚ç‚¹**çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

è¯´æ˜: å¶â¼¦èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰â¼¦èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

```c++
int minDepth(TreeNode* root) {
    if (root == NULL) return 0;

    int lDepth = minDepth(root->left);
    int rDepth = minDepth(root->right);

    if (root->left == NULL && root->right != NULL) return 1 + rDepth;
    if (root->left != NULL && root->right == NULL) return 1 + lDepth;
    
    return lDepth > rDepth ? 1 + rDepth : 1 + lDepth;
}
```



```c++
int minDepth(TreeNode* root) {
    queue<TreeNode*> que;
    if (root == nullptr) return 0;
    que.push(root);
    int depth = 0;

    while (!que.empty()) {
        int size = que.size();
        depth++;
        for (int i = 0; i < size; ++i) {
            TreeNode* node = que.front();
            que.pop();

            if (node->left != nullptr) que.push(node->left);
            if (node->right != nullptr) que.push(node->right);

            if (node->left == nullptr && node->right == nullptr) return depth;  //æå‰æ‰¾åˆ°å¶å­èŠ‚ç‚¹ å°±å¯ä»¥é€€å‡ºäº†
        }

    }
    return depth;
}
```



---

## 222. äºŒå‰æ ‘èŠ‚ç‚¹æ•°

**222. Count Complete Tree Nodes**

å®Œå…¨äºŒå‰æ ‘

åˆ¤æ–­å…¶å·¦å³å­æ ‘æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ï¼Œæ˜¯çš„è¯ç›´æ¥è®¡ç®—æ·±åº¦å¹¶ä¸” `2^h-1`

```c++
int countNodes(TreeNode* root) {
    if (root == NULL) return 0;
    TreeNode* l = root->left;
    TreeNode* r = root->right;
    int ldepth = 1;
    int rdepth = 1;

    while (l) {
        ++ldepth;
        l = l->left;
    }

    while (r) {
        ++rdepth;
        r = r->right;
    }

    if (ldepth == rdepth) {
        return pow(2, ldepth) - 1;
    }

    return 1 + countNodes(root->left) + countNodes(root->right);
}
```



## 9. äºŒå‰æ ‘çš„é«˜åº¦/å¹³è¡¡äºŒå‰æ ‘

å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡1

```c++
int getHeight(TreeNode* node) {
    if (node == NULL) return 0;

    int lheight = getHeight(node->left);
    if (lheight == -1) return -1;
    int rheight = getHeight(node->right);
    if (rheight == -1) return -1;

    if (abs(lheight - rheight) > 1) return -1;

    return 1 + max(lheight, rheight);
}

bool isBalanced(TreeNode* root) {
    return getHeight(root)==-1 ? false : true;
}
```

![1616324886994](assets/1616324886994.png)

æ±‚æ·±åº¦ä»ä¸Šåˆ°ä¸‹æŸ¥ï¼Œå‰åºéå†ã€‚æ±‚é«˜åº¦ä»ä¸‹åˆ°ä¸ŠæŸ¥ï¼Œååºéå†ã€‚æœ€å¤§æ·±åº¦ä¹Ÿå°±æ˜¯æ ¹çš„é«˜åº¦ï¼Œä¹Ÿç”¨ååºéå†ã€‚



## 113. äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

```c++
void dps (TreeNode* root, vector<string> &res, string ans) {
    TreeNode* l = root->left;
    TreeNode* r = root->right;

    if (!l && !r) {
        res.push_back(ans); 
        return;
    }   

    if (l!=NULL) {
        dps(l, res, ans + "->" + to_string(l->val));
    }

    if (r!=NULL) {
        dps(r, res, ans + "->" + to_string(r->val));
    }   

    return;
}

```

å›æº¯é€’å½’æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œæœ‰ä¸€ä¸ªé€’å½’ï¼Œå°±è¦æœ‰ä¸€ä¸ªå›æº¯



## #6-10. å°ç»“





---

## 11. å·¦å¶å­ä¹‹å’Œ

**404. å·¦å¶å­ä¹‹å’Œ**

```c++
int sumOfLeftLeaves(TreeNode* root) {
    if ( root == NULL ) return 0;

    int leftnum = sumOfLeftLeaves( root->left );;
    int rightnum = sumOfLeftLeaves( root->right );

    int midnum = 0;
    if ( root->left && !root->left->left && !root->left->right ) {
        midnum = root->left->val;
    }

    return midnum + leftnum + rightnum;
}
```

é€’å½’ ååºï¼Œå› ä¸ºè¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼ç´¯åŠ æ±‚å–å·¦å¶å­æ•°å€¼ä¹‹å’Œã€‚

**éœ€è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹åˆ¤æ–­æœ¬èŠ‚ç‚¹çš„å±æ€§ã€‚**



---

## 12. æ ‘å·¦ä¸‹è§’çš„å€¼

**513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼**

```c++
int findBottomLeftValue(TreeNode* root) {
    if (root == NULL) return 0;
    queue<TreeNode*> que;
    que.push(root);
    int res = 0;

    while (!que.empty()) {
        int size = que.size();
        for (int i = 0; i < size; ++i) {
            TreeNode* node = que.front();
            que.pop();
            if (node->left) que.push(node->left);
            if (node->right) que.push(node->right);
            if (i == 0) res = node->val;
        }         
    }

    return res;
}
```

**åœ¨æœ€åä¸€è¡Œï¼Œæ‰¾åˆ°æœ€å·¦è¾¹çš„å€¼ã€‚**



å¦‚æœéœ€è¦éå†æ•´æ£µæ ‘ï¼Œé€’å½’å‡½æ•°å°±ä¸èƒ½æœ‰è¿”å›å€¼ã€‚å¦‚æœéœ€è¦éå†æŸä¸€æ¡å›ºå®šè·¯çº¿ï¼Œé€’å½’å‡½æ•°å°±ä¸€å®šè¦æœ‰è¿”å›å€¼ï¼



## 13. è·¯å¾„æ€»å’Œ



**112. è·¯ç»æ€»å’Œ**

```c++
bool traversal(TreeNode* root, int targetSum, int count) {
    if (!root->left && !root->right && count == targetSum) {    //é‡åˆ°å¶å­ç»“ç‚¹ä¸”å€¼ç›¸åŒ,å³æ‰¾åˆ°è·¯å¾„ ç›´æ¥è¿”å›true
        return true;
    }

    if (!root->left && !root->right) {      //é‡åˆ°å¶å­ç»“ç‚¹ä½†å€¼ä¸åŒ,æ²¡æœ‰æ‰¾åˆ°è·¯å¾„ è¿”å›false
        return false;
    }

    if (root->left) {       // å¤„ç†å·¦èŠ‚ç‚¹
        if (traversal(root->left, targetSum, count + root->left->val)) return true;
    }

    if (root->right) {      // å¤„ç†å³èŠ‚ç‚¹
        if (traversal(root->right, targetSum, count + root->right->val)) return true;
    }

    return false;
}

bool hasPathSum(TreeNode* root, int targetSum) {
    if (root == NULL) return false;
    return traversal(root, targetSum, root->val);
}
```

**éå†çš„è·¯çº¿ï¼Œä¸è¦æ±‚éå†æ•´é¢—æ ‘ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°éœ€è¦è¿”å›å€¼ã€‚**



**113. è·¯å¾„æ€»å’ŒII**

```c++
vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
    if(root == NULL) return res;
    tmp.push_back(root->val);
    traversal(root, targetSum, root->val);
    return res;
}


vector<vector<int>> res;
vector<int> tmp;
void traversal(TreeNode* root, int targetSum, int count) {
    if (!root->left && !root->right && count == targetSum) {
        res.push_back(tmp);
        return;
    }

    if (!root->left && !root->right) {
        return;
    }

    if (root->left) {
        tmp.push_back(root->left->val);
        traversal(root->left, targetSum, count + root->left->val);
        tmp.pop_back();
    }

    if (root->right) {
        tmp.push_back(root->right->val);
        traversal(root->right, targetSum, count + root->right->val);
        tmp.pop_back();
    }

    return;
}
```



**éå†æ•´ä¸ªæ ‘ï¼Œæ‰¾åˆ°æ‰€æœ‰è·¯å¾„ï¼Œæ‰€ä»¥é€’å½’å‡½æ•°ä¸è¦è¿”å›å€¼**



---

# äºŒå‰æ ‘çš„ä¿®æ”¹ä¸æ„é€ 

## 106.  æ„é€ äºŒå‰æ ‘

**106. ä»ä¸­åºå’Œååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘**

```c++
TreeNode* traversal (vector<int>& inorder, int instart, int inend, 
                     vector<int>& postorder, int poststart, int postend) {
    if (inend < instart || postend < poststart) return nullptr;

    int mid = instart;
    int rootval = postorder[postend];
    for (int i = instart; i <= inend; ++i) {
        if (inorder[i] == rootval) {
            mid = i;
            break;
        }
    }

    TreeNode* root = new TreeNode(rootval);
    root->left = traversal(inorder, instart, mid - 1, 
                           postorder, poststart, poststart + mid - instart - 1);
    root->right = traversal(inorder, mid + 1, inend, 
                            postorder, poststart + mid - instart, postend - 1);

    return root;
}

TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    return traversal(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);
};

```

â€‹    `leftsize = index - instart;`

![å›¾ç‰‡](assets/640.webp)



**105. ä»ä¸­åºå’Œå‰åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘**

```c++
TreeNode* build(vector<int>& preorder, int prestart, int preend, 
                vector<int>& inorder, int instart, int inend) {
    if (preend < prestart || inend < instart) return nullptr;

    int index;
    for (int i = instart; i < inend; ++i) {
        if (inorder[i] == preorder[prestart]) {
            index = i;
            break;
        }
    } 
	

    TreeNode* root = new TreeNode(preorder[prestart]);
    root->left = build(preorder, prestart + 1, prestart + index - instart,
                       inorder, instart, index - 1);

    root->right = build(preorder, prestart + index - instart + 1, preend,
                        inorder, index + 1, inend);
    return root;
}
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    return build(preorder, 0 , preorder.size()-1, inorder, 0 ,inorder.size()-1);
}
```

â€‹    `leftsize = index - instart;`

![å›¾ç‰‡](assets/640-1616562491143.webp)



---

## 654. æ„é€ ä¸€é¢—æœ€å¤§çš„äºŒå‰æ ‘

**654. æœ€å¤§äºŒå‰æ ‘**

```c++
TreeNode* build(vector<int>& nums, int l, int r) {
    if (l >= r) return nullptr;

    int index = l;
    for (int i = l + 1; i < r; i++) { 
        if (nums[i] > nums[index])  index = i;
    }

    TreeNode* root = new TreeNode(nums[index]);

    root->left = build(nums, l, index);
    root->right = build(nums, index+1, r);
    return root;
}

TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
    return build(nums, 0 ,nums.size());  //å·¦é—­å³å¼€
}
```



---

## #11-15. å°ç»“

å›æº¯éšè—ï¼Œå‡½æ•°å½¢å‚

æ·±åº¦æœ€å¤§ä¸€å®šæ˜¯å¶å­èŠ‚ç‚¹

ä¸‹æ ‡ç´¢å¼•æ•°ç»„ï¼Œä¸è¦æ–°å¼€æ•°ç»„

ifæ§åˆ¶ç©ºèŠ‚ç‚¹è¿›ä¸è¿›é€’å½’



---

## 16. åˆå¹¶ä¸¤ä¸ªäºŒå‰æ ‘

**617. åˆå¹¶äºŒå‰æ ‘**

```c++
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == NULL) return root2;
    if (root2 == NULL) return root1;
    root1->val += root2->val;
    root1->left = mergeTrees(root1->left, root2->left);
    root1->right = mergeTrees(root1->right, root2->right);

    return root1;
}
```



```c++
TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (root1 == NULL) return root2;
    if (root2 == NULL) return root1;

    queue<TreeNode*> que1;
    queue<TreeNode*> que2;

    que1.push(root1);
    que2.push(root2);


    while (!que1.empty() && !que2.empty()) {
        TreeNode* node1 = que1.front();
        que1.pop();
        TreeNode* node2 = que2.front();
        que2.pop();

        node1->val += node2->val;

        if (node1->left && node2->left) {
            que1.push(node1->left);
            que2.push(node2->left);
        } 

        if (node1->right && node2->right) {
            que1.push(node1->right);
            que2.push(node2->right);
        }

        if (!node1->left && node2->left) {
            node1->left = node2->left;
        }

        if (!node1->right && node2->right) {
            node1->right = node2->right;
        } 
    }

    return root1;
}
```







# äºŒå‰æœç´¢æ ‘çš„å±æ€§

## 700. äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

```c++
TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL) return root;

    if (root->val == val) return root;
    if (root->val < val) return searchBST(root->right, val);
    if (root->val > val) return searchBST(root->left, val);

    return nullptr;
}
```





## 98. éªŒè¯äºŒå‰æœç´¢æ ‘

```c++
bool isValidBST(TreeNode* root) {
    if (root == NULL) return true;  
    traversal(root);

    for (int i = 1; i < res.size(); ++i) {
        if (res[i] <= res[i-1]) return false;
    }
    return true;
}

vector<int> res;    
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    res.push_back(root->val);
    traversal(root->right);
} 
```





---

## 530. äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

```c++
public:
    int getMinimumDifference(TreeNode* root) {
        if (root == NULL) return 0;
        traversal(root);

        int ans = INT_MAX;
        for (int i = 1; i < res.size(); ++i) {
            ans = res[i] - res[i-1] < ans ? res[i] - res[i-1] : ans;
        }
        return ans;
    }

private: 
    vector<int> res;
    void traversal(TreeNode* root) {
        if (root == NULL) return; 
        traversal(root->left);
        res.push_back(root->val);
        traversal(root->right);
        return;
    }
```





---

## 501. äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°

```c++
public:
    vector<int> findMode(TreeNode* root) {
        vector<int> res;
        if (root == NULL) return res;
        traversal(root);
        vector<pair<int, int>> vec(mp.begin(), mp.end());
        sort(vec.begin(), vec.end(), cmp);

        res.push_back(vec[0].first);
        for (int i = 1; i < vec.size(); i++) {
            if (vec[i].second == vec[0].second) res.push_back(vec[i].first);
            else break;
        }
        return res;
    }

    bool static cmp (const pair<int, int> a, const pair<int, int> b) {
        return a.second > b.second ? true : false;
    }

private:
    map<int,int> mp;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        mp[root->val]++;
        traversal(root->right);
    }   
```



---

## 508. å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­æ ‘å…ƒç´ å’Œ

```c++
typedef pair<long, int> pli; 

void getSum(TreeNode* root, int &val) {
    if (root == nullptr) return;

    val += root->val;
    getSum(root->left, val);
    getSum(root->right, val);

    return;
}

static bool cmp(const pair<int, int> &p1, const pair<int, int> &p2) {
    return p1.second > p2.second ? true : false;    //æ³¨æ„è¿™é‡Œ>=ä¸è¡Œ æ”¹æˆ > å°±å¯ä»¥
}

vector<int> findFrequentTreeSum(TreeNode* root) {
    map<int, int> mp;

    queue<TreeNode*> q;
    q.push(root);

    while (q.size()) {
        int size = q.size();

        for (int i = 0; i < size; ++i) {
            TreeNode* node = q.front(); q.pop();
            int val = 0;
            getSum(node, val);
            mp[val]++;
            if (node->left != nullptr) q.push(node->left);
            if (node->right != nullptr) q.push(node->right);
        }
    }

    vector<int> res;
    vector<pair<int, int>> tmpv(mp.begin(), mp.end());
    sort(tmpv.begin(), tmpv.end(), cmp);

    int maxn = -1;
    for (auto iter = tmpv.begin(); iter != tmpv.end(); iter++) {
        if (maxn == -1) {
            res.push_back(iter->first);
            maxn = iter->second;
        } else if (iter->second == maxn) {
            res.push_back(iter->first);
        } else {
            break;
        }
        // cout << iter->first << " " << iter->second << endl;
    }


    return res;
}
```







## 814. äºŒå‰æ ‘å‰ªæ

```c++
TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }

    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);

    if (root->left == nullptr && root->right == nullptr && root->val == 0) {
        return nullptr;
    }

    return root;
}
```







----

# äºŒå‰æ ‘å…¬å…±ç¥–å…ˆé—®é¢˜

## 236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆLCA

**ç¥–å…ˆ**çš„å®šä¹‰ï¼š è‹¥èŠ‚ç‚¹ p åœ¨èŠ‚ç‚¹ root çš„å·¦ï¼ˆå³ï¼‰å­æ ‘ä¸­ï¼Œæˆ– p = root ï¼Œåˆ™ç§° root æ˜¯ p çš„ç¥–å…ˆã€‚

**æœ€è¿‘å…¬å…±ç¥–å…ˆ**çš„å®šä¹‰ï¼š è®¾èŠ‚ç‚¹ root ä¸ºèŠ‚ç‚¹ p, q çš„æŸå…¬å…±ç¥–å…ˆï¼Œè‹¥å…¶å·¦å­èŠ‚ç‚¹ root.left å’Œå³å­èŠ‚ç‚¹ root.right éƒ½ä¸æ˜¯ p,q çš„å…¬å…±ç¥–å…ˆï¼Œåˆ™ç§° root æ˜¯ â€œæœ€è¿‘çš„å…¬å…±ç¥–å…ˆâ€ ã€‚





è‡ªåº•å‘ä¸ŠæŸ¥æ‰¾å°±å¥½äº†

å›æº¯å•Šï¼Œâ¼†å‰æ ‘å›æº¯çš„è¿‡ç¨‹å°±æ˜¯ä»ä½åˆ°ä¸Šã€‚

ååºéå†å°±æ˜¯å¤©ç„¶çš„å›æº¯è¿‡ç¨‹ï¼Œæœ€å…ˆå¤„ç†çš„â¼€å®šæ˜¯å¶å­èŠ‚ç‚¹ã€‚



å¦‚ä½•åˆ¤æ–­â¼€ä¸ªèŠ‚ç‚¹æ˜¯èŠ‚ç‚¹ q å’ŒèŠ‚ç‚¹ p çš„å…¬å…±å…¬å…±ç¥–å…ˆå‘¢ï¼Ÿ

å¦‚æœæ‰¾åˆ°â¼€ä¸ªèŠ‚ç‚¹ï¼Œå‘ç°å·¦å­æ ‘å‡ºç°ç»“ç‚¹pï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹qï¼Œæˆ–è€… å·¦å­æ ‘å‡ºç°ç»“ç‚¹qï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹pï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹å°±æ˜¯èŠ‚ç‚¹på’Œqçš„æœ€è¿‘**å…¬å…±ç¥–å…ˆ**ã€‚



**è‡ªåº•å‘ä¸Š**ä»å¶å­èŠ‚ç‚¹å¼€å§‹æ›´æ–°çš„ï¼Œæ‰€ä»¥åœ¨æ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„å…¬å…±ç¥–å…ˆä¸­ä¸€å®šæ˜¯**æ·±åº¦æœ€å¤§çš„ç¥–å…ˆå…ˆè¢«è®¿é—®åˆ°**

```c++
TreeNode* ans;
bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
    // å½“è¶Šè¿‡å¶èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥è¿”å› null
    if (root == nullptr) return false;

    bool lson = dfs(root->left, p, q);
    bool rson = dfs(root->right, p, q);
    // å½“ root ç­‰äº p, q åˆ™ç›´æ¥è¿”å› root
    if (lson && rson) {
        ans = root;
    }

    //  x æ°å¥½æ˜¯ p èŠ‚ç‚¹æˆ– q èŠ‚ç‚¹ä¸”å®ƒçš„å·¦å­æ ‘æˆ–å³å­æ ‘æœ‰ä¸€ä¸ªåŒ…å«äº†å¦ä¸€ä¸ªèŠ‚ç‚¹çš„æƒ…å†µ
    if ((root->val == p->val || root->val == q->val) && (lson || rson)) {    
        ans = root;
    }

    return lson || rson || (root->val == p->val || root->val == q->val);
}

TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    dfs(root, p, q);
    return ans;
}
```



![Picture1.png](assets/1599885247-rxcHcZ-Picture1.png)



æ ¹æ®ä»¥ä¸Šå®šä¹‰ï¼Œè‹¥ root æ˜¯ p, q çš„ æœ€è¿‘å…¬å…±ç¥–å…ˆ ï¼Œåˆ™åªå¯èƒ½ä¸ºä»¥ä¸‹æƒ…å†µä¹‹ä¸€ï¼š

- p å’Œ q åœ¨ root çš„å­æ ‘ä¸­ï¼Œä¸”åˆ†åˆ— root çš„ å¼‚ä¾§ï¼ˆå³åˆ†åˆ«åœ¨å·¦ã€å³å­æ ‘ä¸­ï¼‰ï¼›
- p = root ï¼Œä¸” q åœ¨ root çš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›
- q = root ï¼Œä¸” p åœ¨ root çš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›



![Picture2.png](assets/1599885247-mgYjRv-Picture2.png)

- ç»ˆæ­¢æ¡ä»¶ï¼š

  - å½“è¶Šè¿‡å¶èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥è¿”å› nullï¼›

  - å½“ root ç­‰äº p æˆ– qï¼Œåˆ™ç›´æ¥è¿”å› root ï¼›

- é€’æ¨å·¥ä½œï¼š

  - å¼€å¯é€’å½’å·¦å­èŠ‚ç‚¹ï¼Œè¿”å›å€¼è®°ä¸º leftï¼›

  - å¼€å¯é€’å½’å³å­èŠ‚ç‚¹ï¼Œè¿”å›å€¼è®°ä¸º right ï¼›

- è¿”å›å€¼ï¼š æ ¹æ® left å’Œ rightï¼Œå¯å±•å¼€ä¸ºå››ç§æƒ…å†µï¼›
  1. å½“ left å’Œ right åŒæ—¶ä¸ºç©º ï¼šè¯´æ˜ root çš„å·¦ / å³å­æ ‘ä¸­éƒ½ä¸åŒ…å« p,q è¿”å› nullï¼›
  2. å½“ left å’Œ right åŒæ—¶ä¸ä¸ºç©º ï¼šè¯´æ˜ p, q åˆ†åˆ—åœ¨ root çš„ å¼‚ä¾§ ï¼ˆåˆ†åˆ«åœ¨ å·¦ / å³å­æ ‘ï¼‰ï¼Œå› æ­¤ root ä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œè¿”å› rootï¼›
  3. å½“ left ä¸ºç©º ï¼Œright ä¸ä¸ºç©º ï¼šp,q éƒ½ä¸åœ¨ root çš„å·¦å­æ ‘ä¸­ï¼Œç›´æ¥è¿”å› rightã€‚å…·ä½“å¯åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š
     - p,q å…¶ä¸­ä¸€ä¸ªåœ¨ root çš„ å³å­æ ‘ ä¸­ï¼Œæ­¤æ—¶ right æŒ‡å‘ pï¼ˆå‡è®¾ä¸º p ï¼‰ï¼›
     - p,q ä¸¤èŠ‚ç‚¹éƒ½åœ¨ root çš„ å³å­æ ‘ ä¸­ï¼Œæ­¤æ—¶çš„ right æŒ‡å‘ æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹ ï¼›
  4. å½“ left ä¸ä¸ºç©º ï¼Œ right ä¸ºç©º ï¼šä¸æƒ…å†µ 3. åŒç†ï¼›



```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {		
    if (root == nullptr) return nullptr;		// ç»ˆæ­¢æ¡ä»¶1
    if (root == p || root == q) return root;	// ç»ˆæ­¢æ¡ä»¶2
    
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    
    if (left == nullptr && right == nullptr) return nullptr; // 1.
    if (left == nullptr) return right; // 3.
    if (right == nullptr) return left; // 4.
    return root; // 2. if (left != null && right != null)
}
```







## #16-21. å°ç»“

ä¸€èµ·æ“ä½œä¸¤ä¸ªæ•°ï¼Œç”¨é˜Ÿåˆ—å±‚åºéå†ã€‚



---

## 22. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

**450. åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹**

```c++
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == nullptr) return root;
    if (root->val == key) {
        if (root->left == NULL) return root->right;
        else if (root->right == NULL) return root->left;
        else {
            TreeNode* cur = root->right;
            while (cur->left != nullptr) {
                cur = cur->left;
            }
            cur->left = root->left;
            TreeNode* tmp = root;
            root = root->right;
            delete(tmp);

            return root;
        }
    }

    TreeNode* tmp = new TreeNode(NULL);
    if (root->val > key) root->left = deleteNode(root->left, key);
    else root->right = deleteNode(root->right, key);

    return root;
}
```





---

# äºŒå‰æœç´¢æ ‘çš„ä¿®æ”¹ä¸æ„é€ 

---

## 23. ä¿®å‰ªäºŒå‰æœç´¢æ ‘

**669. ä¿®å‰ªäºŒå‰æœç´¢æ ‘**

```c++
TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (root == nullptr) return nullptr;
    if (root->val < low) {
        TreeNode* right = trimBST(root->right, low, high);
        return right;
    }

    if (root->val > high) {
        TreeNode* left = trimBST(root->left, low, high);
        return left;
    }

    root->left = trimBST(root->left, low, high);
    root->right = trimBST(root->right, low, high);

    return root;
}
```





---

## 24. æ„é€ ä¸€æ£µäºŒå‰æœç´¢æ ‘

**108. å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘**

```c++
TreeNode* getBST(vector<int>& nums, int start, int end) {
    if (start > end) return nullptr;
    int index = start + (end - start) / 2;
    TreeNode* root = new TreeNode(nums[index]);
    root->left = getBST(nums, start, index - 1);
    root->right = getBST(nums, index + 1, end);
    return root;
}
```



---

## 25. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘

**538. æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘**

```c++
int tmp = 0;
void traversal(TreeNode* root) {
    if (root == nullptr) return;
    traversal(root->right);
    root->val = root->val + tmp;
    tmp = root->val;
    traversal(root->left);
    return;
}

TreeNode* convertBST(TreeNode* root) {
    traversal(root);
    return root;
}
```



æ¶‰åŠåˆ°äºŒå‰æ ‘çš„æ„é€ ,æ— è®ºæ™®é€šäºŒå‰æ ‘è¿˜æ˜¯äºŒå‰æœç´¢æ ‘ä¸€å®šå‰åº,éƒ½æ˜¯å…ˆæ„é€ ä¸­èŠ‚ç‚¹ã€‚
æ±‚æ™®é€šäºŒå‰æ ‘çš„å±æ€§,ä¸€èˆ¬æ˜¯ååº,ä¸€èˆ¬è¦é€šè¿‡é€’å½’å‡½æ•°çš„è¿”å›å€¼åšè®¡ç®—ã€‚
æ±‚äºŒå‰æœç´¢æ ‘çš„å±æ€§,ä¸€å®šæ˜¯ä¸­åºäº†,è¦ä¸æµªè´¹äº†æœ‰åºæ€§ã€‚





---

# ğŸ’—449. åºåˆ—åŒ–ååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘

- åºåˆ—åŒ–æ ‘ä¸ºå­—ç¬¦ä¸²
- ååºåˆ—åŒ–å°†å­—ç¬¦ä¸²(å­—ç¬¦ä¸²ä¹Ÿå¯ä»¥è½¬ä¸ºæ•°ç»„)è½¬ä¸ºæ ‘
- åˆ†å‰²å­—ç¬¦ä¸²

```c++
// åºåˆ—åŒ–
string serDfs(TreeNode* root) {
    if (root == nullptr) return "";
    string s= "";
    queue<TreeNode*> q;
    q.push(root);

    while (q.size()) {
        TreeNode* node = q.front(); q.pop();

        if (node == nullptr) s += "null,";
        else {
            s += (to_string(node->val) + ",");
            q.push(node->left);
            q.push(node->right);
        }
    }

    return s;
}

// Encodes a tree to a single string.
string serialize(TreeNode* root) {
    string s = serDfs(root);
    cout << s << endl;
    return s;
}

// [2,1,3]
// 2,1,3,null,null,null,null,
```



```c++
//ååºåˆ—åŒ–
void stringSplit(string str, char split, vector<string>& nums)
{
    istringstream iss(str);	// è¾“å…¥æµ
    string token;			// æ¥æ”¶ç¼“å†²åŒº
    while (getline(iss, token, split))	// ä»¥splitä¸ºåˆ†éš”ç¬¦
    {
        nums.push_back(token.c_str());
        cout << token << endl; // è¾“å‡º
    }
}


// Decodes your encoded data to tree.
TreeNode* deserialize(string data) {
    if (data == "") return nullptr;

    vector<string> nums;
    stringSplit(data, ',', nums);

    TreeNode* root = new TreeNode(atoi(nums[0].c_str()));

    queue<TreeNode*> q;
    q.push(root);

    int idx = 1;
    while (q.size()) {
        TreeNode* node = q.front(); q.pop();

        if (nums[idx] != "null") {
            node->left = new TreeNode(atoi(nums[idx].c_str()));
            q.push(node->left);
        }
        idx++;

        if (nums[idx] != "null") {
            node->right = new TreeNode(atoi(nums[idx].c_str()));
            q.push(node->right);
        }
        idx++;
    }

    return root;
}
```



# 297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–

åºåˆ—åŒ–æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼ŒæŠŠå¶å­èŠ‚ç‚¹çš„å·¦å³å­æ ‘æ ‡æˆç‰¹æ®Šçš„ç¬¦å·ï¼Œæ–¹ä¾¿ååºåˆ—åŒ–æ—¶æ„å»ºï¼Œ

```c++
class Codec {
public:
    void dfs(TreeNode* root, string &s) { // ä¸­åº
        if (root == nullptr) {
            s += "-1111,";
            return;
        }
        
        s += to_string(root->val) + ",";
        dfs(root->left, s);        
        dfs(root->right, s);
    }

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string res;
        dfs(root, res);
        //cout << res;
        return res;
    }

    void stringsplit(string &s, char split, vector<int> &nums) {
        istringstream iss(s); 
        string token;
        while (getline(iss, token, split)) {
            nums.push_back(stoi(token));
        }
        return;
    }

    TreeNode* dfsBuild(vector<int> &nums, int &idx) {
        if (nums[idx] == -1111) return nullptr;
        TreeNode* root = new TreeNode(nums[idx]);
        root->left = dfsBuild(nums, ++idx);
        root->right = dfsBuild(nums, ++idx);
        return root;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        vector<int> nums;
        stringsplit(data, ',', nums);
        int idx = 0;
        TreeNode* res = dfsBuild(nums, idx);        
        return res;
    }
};
```







---

# 513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

## BFS


```c++
int findBottomLeftValue(TreeNode* root) {
    queue<TreeNode*> q;
    q.push(root);

    int res = root->val;


    while (q.size()) {
        int size = q.size();

        for (int i = 0; i < size; ++i) {
            TreeNode* cur = q.front(); q.pop();
            if (i == 0) res = cur->val;

            if (cur->left != nullptr) q.push(cur->left);
            if (cur->right != nullptr) q.push(cur->right);
        }
    }

    return res;
}
```
> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå³æ‰€æœ‰èŠ‚ç‚¹å…¨éå†ä¸€é
> + ç©ºé—´å¤æ‚åº¦: O(N)ï¼Œæ»¡å®Œå…¨äºŒå‰æ ‘ï¼Œå…¶ä¸­ä¸€æ»¡å±‚å…¨å­˜

----

## DFS

å…ˆåºéå†ï¼Œå·¦å³ä¸­

- `å·¦` åœ¨ `å³ä¸­` çš„å‰è¾¹ï¼Œä¿è¯æœ€å·¦èŠ‚ç‚¹
- `å·¦å³` åœ¨ `ä¸­` çš„å‰è¾¹ï¼Œä¿è¯æœ€åº•å±‚

```c++
class Solution {
public:
    void dfs(TreeNode* root, int level) {
        if (root->left != nullptr) dfs(root->left, level + 1);
        if (root->right != nullptr) dfs(root->right, level + 1);
        
        if (maxlevel < level) {
            maxlevel = level;
            res = root->val;
            return;
        }

        return;
    }

    int findBottomLeftValue(TreeNode* root) {
        maxlevel = -1;
        dfs(root, 0);
        return res;
    }

private:
    int res;
    int maxlevel;
};
```


> + æ—¶é—´å¤æ‚åº¦: O(N)ï¼Œå³å…¨éƒ¨éå†ä¸€é
> + ç©ºé—´å¤æ‚åº¦: O(height)ï¼Œæ ‘çš„é«˜åº¦ï¼Œæœ€å·®ä¸º O(N)





# 1161. æœ€å¤§å±‚å†…å…ƒç´ å’Œ

```c++
const int inf = 0x3f3f3f3f;
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        vector<pair<int, int>> vecs;
        int res = -inf;

        queue<TreeNode*> q;
        q.push(root);

        int reslevel = 1, level = 1;
        while (q.size()) {          
            int size = q.size();
            int resT = 0;
            for (int i = 0; i < size; ++i) {
                auto cur = q.front(); q.pop();  
                resT += cur->val;
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }

            if (res < resT) {
                res = resT;
                reslevel = level;
            }
              
            level++;
        }

        return reslevel;
    }
};
```





-----

# 230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

```c++
void dfs(TreeNode* root, vector<int> &res) {
    if (root == nullptr) return;

    dfs(root->left, res);
    res.push_back(root->val);
    dfs(root->right, res);
}

int kthSmallest(TreeNode* root, int k) {
    vector<int> res;
    dfs(root, res);

    return res[k-1];
}
```









----

# é¢è¯•é¢˜ 04.06. åç»§è€…

https://leetcode.cn/problems/successor-lcci/

åªéœ€è¦æ‰¾åˆ°èŠ‚ç‚¹ p çš„åç»§èŠ‚ç‚¹ï¼Œå› æ­¤ä¸éœ€è¦ç»´æŠ¤å®Œæ•´çš„ä¸­åºéå†åºåˆ—ï¼Œåªéœ€è¦åœ¨ä¸­åºéå†çš„è¿‡ç¨‹ä¸­ç»´æŠ¤ä¸Šä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹å’Œå½“å‰è®¿é—®çš„èŠ‚ç‚¹



ä¸­åºéå†ç”¨ prev è®°å½•å…¶å…ˆé©±èŠ‚ç‚¹ï¼ˆå› ä¸ºæ˜¯æ ˆï¼Œæ‰€ä»¥æ˜¯å…ˆé©±ï¼‰$\mathcal{O}(N)$

```c++
TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    TreeNode* prev = nullptr;
    stack<TreeNode*> st;
    if (root != nullptr) st.push(root);

    while (st.size()) {
        auto now = st.top(); st.pop();

        if (now != nullptr) {
            if (now->right != nullptr) st.push(now->right);
            st.push(now);
            st.push(nullptr);
            if (now->left != nullptr) st.push(now->left);
        } else {
            now = st.top();
            if (prev == p) return now; 
            st.pop();
            prev = now;
        }
    }

    return nullptr;
}
```







äºŒå‰æœç´¢æ ‘çš„ä¸€ä¸ªæ€§è´¨æ˜¯ä¸­åºéå†åºåˆ—å•è°ƒé€’å¢ï¼Œå› æ­¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ p çš„åç»§èŠ‚ç‚¹æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

åç»§èŠ‚ç‚¹çš„èŠ‚ç‚¹å€¼å¤§äº p çš„èŠ‚ç‚¹å€¼ï¼›

åç»§èŠ‚ç‚¹æ˜¯èŠ‚ç‚¹å€¼å¤§äº p çš„èŠ‚ç‚¹å€¼çš„æ‰€æœ‰èŠ‚ç‚¹ä¸­èŠ‚ç‚¹å€¼æœ€å°çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚



åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œå¯ä»¥åœ¨**ä¸åšä¸­åºéå†çš„æƒ…å†µä¸‹æ‰¾åˆ°èŠ‚ç‚¹ p çš„åç»§èŠ‚ç‚¹**ã€‚

- å¦‚æœèŠ‚ç‚¹ p çš„å³å­æ ‘**ä¸ä¸ºç©º**ï¼Œåˆ™èŠ‚ç‚¹ p çš„åç»§èŠ‚ç‚¹åœ¨å…¶å³å­æ ‘ä¸­ï¼Œåœ¨å…¶**å³å­æ ‘ä¸­å®šä½åˆ°æœ€å·¦è¾¹çš„èŠ‚ç‚¹**ï¼Œå³ä¸ºèŠ‚ç‚¹ p çš„åç»§èŠ‚ç‚¹ã€‚

- å¦‚æœèŠ‚ç‚¹ p çš„å³å­æ ‘**ä¸ºç©º**ï¼Œåˆ™éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†å¯»æ‰¾èŠ‚ç‚¹ p çš„ç¥–å…ˆèŠ‚ç‚¹ã€‚

å°†ç­”æ¡ˆåˆå§‹åŒ–ä¸º nullã€‚ç”¨ node è¡¨ç¤ºéå†åˆ°çš„èŠ‚ç‚¹ã€‚æ¯æ¬¡æ¯”è¾ƒ node çš„èŠ‚ç‚¹å€¼å’Œ p çš„èŠ‚ç‚¹å€¼ï¼Œæ‰§è¡Œç›¸åº”æ“ä½œï¼š

- å¦‚æœ node çš„**èŠ‚ç‚¹å€¼å¤§äº p çš„èŠ‚ç‚¹å€¼**ï¼Œåˆ™ p çš„åç»§èŠ‚ç‚¹å¯èƒ½æ˜¯ node æˆ–è€…åœ¨ node çš„å·¦å­æ ‘ä¸­ï¼Œå› æ­¤ç”¨ node æ›´æ–°ç­”æ¡ˆï¼Œå¹¶å°† node ç§»åŠ¨åˆ°å…¶å·¦å­èŠ‚ç‚¹ç»§ç»­éå†ï¼›

- å¦‚æœ node çš„**èŠ‚ç‚¹å€¼å°äºæˆ–ç­‰äº p çš„èŠ‚ç‚¹å€¼**ï¼Œåˆ™ p çš„åç»§èŠ‚ç‚¹å¯èƒ½åœ¨ node çš„å³å­æ ‘ä¸­ï¼Œå› æ­¤å°† node ç§»åŠ¨åˆ°å…¶å³å­èŠ‚ç‚¹ç»§ç»­éå†ã€‚

ç”±äºåœ¨éå†è¿‡ç¨‹ä¸­ï¼Œå½“ä¸”ä»…å½“ node çš„èŠ‚ç‚¹å€¼å¤§äº p çš„èŠ‚ç‚¹å€¼çš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šç”¨ node æ›´æ–°ç­”æ¡ˆï¼Œå› æ­¤å½“èŠ‚ç‚¹ p æœ‰åç»§èŠ‚ç‚¹æ—¶ä¸€å®šå¯ä»¥æ‰¾åˆ°åç»§èŠ‚ç‚¹ï¼Œå½“èŠ‚ç‚¹ p æ²¡æœ‰åç»§èŠ‚ç‚¹æ—¶ç­”æ¡ˆä¸€å®šä¸º nullã€‚



```c++
TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    if (p->right != nullptr) {
        TreeNode* node = p->right;

        while (node->left != nullptr) {
            node = node->left;
        }
        return node;
    }


    TreeNode* ans = nullptr;
    TreeNode* node = root;
    while (node != nullptr) {
        if (node->val > p->val) {
            ans = node;
            node = node->left;
        } else {
            node = node->right;
        }
    }

    return ans;
}
```





---

# å››å‰æ ‘

## 558. å››å‰æ ‘äº¤é›†

é¢˜ç›®ç»™å‡ºä¸¤æ£µã€Œå››å‰æ ‘ã€--  $\textit{quadTree}_1$ å’Œ $\textit{quadTree}_2$ ï¼Œå®ƒä»¬åˆ†åˆ«ä»£è¡¨ä¸€ä¸ª $n \times n$ çš„çŸ©é˜µï¼Œä¸”æ¯ä¸€ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯çˆ¶èŠ‚ç‚¹å¯¹åº”çŸ©é˜µåŒºåŸŸçš„ $\dfrac{1}{4}$ åŒºåŸŸï¼š

- $\textit{topLeft}$ èŠ‚ç‚¹ä¸ºå…¶çˆ¶èŠ‚ç‚¹å¯¹åº”çš„çŸ©é˜µåŒºåŸŸå·¦ä¸Šè§’çš„ $\dfrac{1}{4}$ åŒºåŸŸã€‚
- $\textit{topRight}$ èŠ‚ç‚¹ä¸ºå…¶çˆ¶èŠ‚ç‚¹å¯¹åº”çš„çŸ©é˜µåŒºåŸŸå³ä¸Šè§’çš„ $\dfrac{1}{4}$ åŒºåŸŸã€‚
- $\textit{bottomLeft}$ èŠ‚ç‚¹ä¸ºå…¶çˆ¶èŠ‚ç‚¹å¯¹åº”çš„çŸ©é˜µåŒºåŸŸå·¦ä¸‹è§’çš„ $\dfrac{1}{4}$ åŒºåŸŸã€‚
- $\textit{bottomRight}$ èŠ‚ç‚¹ä¸ºå…¶çˆ¶èŠ‚ç‚¹å¯¹åº”çš„çŸ©é˜µåŒºåŸŸå³ä¸‹è§’çš„ $\dfrac{1}{4}$åŒºåŸŸã€‚



æˆ‘ä»¬éœ€è¦æŠŠè¿™ä¸¤ä¸ªçŸ©é˜µä¸­çš„å¯¹åº”ä½ç½®çš„å€¼è¿›è¡Œã€Œæˆ–ã€æ“ä½œï¼Œç„¶åè¿”å›æ“ä½œåçš„çŸ©é˜µå³å¯ã€‚å¯¹äº $\forall x \in \{0,1\}$ï¼Œæœ‰ $0 ~|~ x = x$ å’Œ $1 ~|~ x = 1$ æˆç«‹ã€‚é‚£ä¹ˆæˆ‘ä»¬æŒ‰ç…§ä¸¤æ£µæ ‘çš„å¯¹åº”çš„èŠ‚ç‚¹æ¥è¿›è¡Œåˆå¹¶æ“ä½œï¼Œå‡è®¾å½“å‰æˆ‘ä»¬æ“ä½œçš„ä¸¤ä¸ªèŠ‚ç‚¹åˆ†åˆ«ä¸º $\textit{node}_1$ å’Œ $\textit{node}_2$ï¼Œè®°èŠ‚ç‚¹çš„åˆå¹¶æ“ä½œä¸ºï¼š

- $\textit{node}_1$ ä¸ºå¶å­èŠ‚ç‚¹æ—¶ï¼š
  - å¦‚æœ $\textit{node}_1$ çš„å€¼ä¸º 1ï¼Œé‚£ä¹ˆ $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_1$ ã€‚
  - å¦åˆ™ $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_2$ ã€‚
- $\textit{node}_2$ ä¸ºå¶å­èŠ‚ç‚¹æ—¶ï¼š
  - å¦‚æœ $\textit{node}_2$ çš„å€¼ä¸º 1ï¼Œé‚£ä¹ˆ $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_2$ã€‚
  - å¦åˆ™ $\textit{node}_1 ~|~ \textit{node}_2 = \textit{node}_1$ã€‚

- ä¸¤è€…éƒ½ä¸æ˜¯å¶å­èŠ‚ç‚¹æ—¶ï¼šé‚£ä¹ˆåˆ†åˆ«å¯¹ä¸¤è€…çš„å››ä¸ªå­èŠ‚ç‚¹æ¥è¿›è¡Œå¯¹åº”çš„åˆ†æ²»å¤„ç†â€”â€”åˆ†åˆ«è¿›è¡Œåˆå¹¶æ“ä½œï¼Œç„¶åå†åˆ¤æ–­åˆå¹¶åçš„å››ä¸ªå­èŠ‚ç‚¹çš„å¯¹åº”åŒºåŸŸæ˜¯å¦éƒ½ä¸ºä¸€ä¸ªå…¨ 00 æˆ–è€…å…¨ 11 åŒºåŸŸï¼Œå¦‚æœæ˜¯åˆ™åŸèŠ‚ç‚¹ä¸ºå¶å­èŠ‚ç‚¹ï¼Œå¦åˆ™åŸèŠ‚ç‚¹ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œä¸”å››ä¸ªå­èŠ‚ç‚¹ä¸ºä¸Šé¢åˆå¹¶æ“ä½œåçš„å››ä¸ªå¯¹åº”å­èŠ‚ç‚¹ã€‚

```c++
Node* intersect(Node* quadTree1, Node* quadTree2) {
    if (quadTree1->isLeaf) {
        if (quadTree1->val) {
            return new Node(true, true);
        }
        return new Node(quadTree2->val, quadTree2->isLeaf, quadTree2->topLeft, quadTree2->topRight, quadTree2->bottomLeft, quadTree2->bottomRight);
    }
    if (quadTree2->isLeaf) {
        return intersect(quadTree2, quadTree1);
    }
    Node* o1 = intersect(quadTree1->topLeft, quadTree2->topLeft);
    Node* o2 = intersect(quadTree1->topRight, quadTree2->topRight);
    Node* o3 = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft);
    Node* o4 = intersect(quadTree1->bottomRight, quadTree2->bottomRight);
    if (o1->isLeaf && o2->isLeaf && o3->isLeaf && o4->isLeaf && o1->val == o2->val && o1->val == o3->val && o1->val == o4->val) {
        return new Node(o1->val, true);
    }
    return new Node(false, false, o1, o2, o3, o4);
}
```







---

# ç‚æœµè‰æ ‘

è¦æ±‚æˆ‘ä»¬å®ç°ä¸€ç§æ•°æ®ç»“æ„ï¼Œå¯ä»¥è¾ƒå¿«åœ°å®ç°ï¼š

- åŒºé—´åŠ 
- åŒºé—´èµ‹å€¼
- æ±‚åŒºé—´ç¬¬kå¤§å€¼
- æ±‚åŒºé—´næ¬¡æ–¹å’Œ



èµ·æºäº[CF896C](https://link.zhihu.com/?target=https%3A//codeforces.com/problemset/problem/896/C)



ç‚æœµè‰æ ‘çš„æ€æƒ³åœ¨äºéšæœºæ•°æ®ä¸‹çš„åŒºé—´èµ‹å€¼æ“ä½œå¾ˆå¯èƒ½è®©**å¤§é‡å…ƒç´ å˜ä¸ºåŒä¸€ä¸ªæ•°**ã€‚æ‰€ä»¥æˆ‘ä»¬ä»¥ä¸‰å…ƒç»„ <l,r,v> çš„å½¢å¼ä¿å­˜æ•°æ®ï¼ˆåŒºé—´ $[l,r]$ ä¸­çš„å…ƒç´ çš„å€¼éƒ½æ˜¯vï¼‰ï¼š

![img](assets/v2-e2bfb654e0549283734097606845b695_720w.jpg)

```c++
using ll = long long;

struct Node {
  	ll l, r;
  	mutable ll v;	// è¿™é‡Œmutable é˜²æ­¢CE
    Node(ll l, ll r, ll v) : l(l), r(r), v(v) {} //æ„é€ å‡½æ•°
    bool operator<(const Node &node) const {	// é‡è½½å°äºè¿ç®—ç¬¦
        return l < node.l;
    }
};
// mutable çªç ´ const çš„é™åˆ¶è€Œè®¾ç½®çš„ã€‚è¢« mutable ä¿®é¥°çš„å˜é‡ï¼ˆmutable åªèƒ½ç”¨äºä¿®é¥°ç±»ä¸­çš„éé™æ€æ•°æ®æˆå‘˜ï¼‰ï¼Œå°†æ°¸è¿œå¤„äºå¯å˜çš„çŠ¶æ€ï¼Œå³ä½¿åœ¨ä¸€ä¸ª const å‡½æ•°ä¸­ã€‚

// è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä¿®æ”¹å·²ç»æ’å…¥ set çš„å…ƒç´ çš„ v å€¼ï¼Œè€Œä¸ç”¨å°†è¯¥å…ƒç´ å–å‡ºåé‡æ–°åŠ å…¥ set
```



æŠŠè¿™äº›ä¸‰å…ƒç»„å­˜å‚¨åˆ°seté‡Œ

```c++
set<Node> tree;
```

è¦æŠŠç»“æ„ä½“æ”¾è¿› `set` é‡Œéœ€è¦é‡è½½å°äºè¿ç®—ç¬¦ï¼Œ `set` ä¼šä¿è¯å†…éƒ¨å…ƒç´ æœ‰åºï¼ˆæ’å…¥ã€åˆ é™¤å’ŒæŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ $O(\log n)$ï¼‰ã€‚



ç„¶è€Œï¼Œè¿›è¡ŒåŒºé—´æ“ä½œæ—¶å¹¶ä¸æ€»æ˜¯é‚£ä¹ˆå¹¸è¿ï¼Œå¯èƒ½ä¼šæŠŠåŸæœ¬è¿ç»­çš„åŒºé—´æ–­å¼€ã€‚éœ€è¦ä¸€ä¸ªå‡½æ•°å®ç° â€œæ–­å¼€â€ çš„æ“ä½œï¼ŒæŠŠ <l, r, v> æ–­æˆ <l, pos-1, v> å’Œ <pos, r, v>

```c++
auto split(ll pos) {	// è‹¥ä¸æ”¯æŒ c++14ï¼Œautoå¿…é¡»æ”¹ä¸º set<node>::iterator
    auto it = tree.lower_bound(Node(pos, 0, 0));	// å¯»æ‰¾å·¦ç«¯ç‚¹>= posçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    // è‹¥ä¸æ”¯æŒC++11ï¼Œautoé¡»æ”¹ä¸ºset<node>::iterator
    if (it != tree.end() && it->l == pos) //å¦‚æœå­˜åœ¨ä»¥posä¸ºå·¦ç«¯ç‚¹çš„èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        return it;
    
    it--;	//å¦åˆ™å¾€å‰æ•°ä¸€ä¸ªèŠ‚ç‚¹
    ll l = it->l, r = it->r, v = it->v;
    tree.erase(it);
    tree.insert(Node(l, pos - 1, v)); //æ’å…¥ <l, pos-1, v> å’Œ <pos, r, v>
	return tree.insert(Node(pos, r, v)).first;	// è¿”å›ä»¥poså¼€å¤´çš„èŠ‚ç‚¹çš„è¿­ä»£å™¨
    // inserté»˜è®¤è¿”å›å€¼æ˜¯ä¸€ä¸ªpairï¼Œç¬¬ä¸€ä¸ªæˆå‘˜æ˜¯æˆ‘ä»¬è¦çš„
}
```



ä¾‹å¦‚åˆšåˆšçš„æƒ…å†µï¼Œå¦‚æœè¦split(4)ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ

![img](assets/v2-e2bfb654e0549283734097606845b695_720w-16501085948492.jpg)

é¦–å…ˆ `lower_bound`ï¼Œæ‰¾åˆ°å·¦ç«¯ç‚¹å¤§äºç­‰äº4çš„èŠ‚ç‚¹ <5,6,3>ã€‚å®ƒçš„å·¦ç«¯ç‚¹ä¸æ˜¯4ï¼Œæ‰€ä»¥å›é€€ï¼Œå¾—<2,4,2>ã€‚æˆ‘ä»¬æŠŠèŠ‚ç‚¹<2,4,2>åˆ é™¤ï¼Œç„¶åæ’å…¥<2,3,2>åŠ<4,4,2>å³å¯ã€‚



ç‚æœµè‰æ ‘çš„ç²¾é«“åœ¨äº**åŒºé—´èµ‹å€¼**ã€‚è€ŒåŒºé—´èµ‹å€¼æ“ä½œçš„å†™æ³•ä¹Ÿæå…¶ç®€å•ï¼š

```c++
void assign(ll l, ll r, ll v)  {
    auto end = split(r + 1), begin = split(l);	// é¡ºåºä¸èƒ½é¢ å€’
    tree.erase(begin, end);	// æ¸…é™¤ä¸€ç³»åˆ—èŠ‚ç‚¹
    tree.insert(Node(l, r, v));	// æ’å…¥æ–°çš„èŠ‚ç‚¹
}
```

æŠŠèŒƒå›´å†…çš„èŠ‚ç‚¹å…¨éƒ¨åˆ é™¤ï¼Œç„¶åæ¢ä¸Šæ–°çš„ï¼ˆèŒƒå›´è¾ƒå¤§çš„ï¼‰èŠ‚ç‚¹è€Œå·²ã€‚åªæ˜¯éœ€è¦æ³¨æ„æ±‚endå’Œbeginçš„é¡ºåºä¸èƒ½é¢ å€’ï¼Œå› ä¸ºsplit(end)å¯èƒ½æŠŠbeginåŸæ¥æ‰€åœ¨çš„èŠ‚ç‚¹æ–­å¼€ã€‚





