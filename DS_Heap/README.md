# 堆

## 1. 定义与基本操作

​	堆是一颗**完全二叉树**,树中的每个结点的值都大于等于左右孩子结点的值(**大顶堆**),小于等于左右孩子结点的值(**小顶堆**).一般用于**优先队列**的实现.

![1565183394776](assets/1565183394776.png)

![1565183450485](assets/1565183450485.png)

![1565183487381](assets/1565183487381.png)

![1565183521253](assets/1565183521253.png)

![1565183537174](assets/1565183537174.png)

```C++
//数组存储完全二叉树			结点按层序存储于数组中
//第一个结点将存储与数组的1号位		数组i号位表示的结点的左孩子就是2i号位   右孩子2i+1
const int maxn=100;
//heap为堆,n为元素个数
int heap[maxn],n=10;
```

```c++
//对heap数组在[low,high]范围进行向下调整
//其中low为欲调整结点的数组下标,high一般为堆的最后一个元素的数组下标
void downAdjust(int low,int high){
    int i=low,j=i*2;	//i为欲调整结点,j为左孩子
    while(j<=high){		//存在孩子结点
        //如果右孩子存在,且右孩子的值大于左孩子
        if(j+1<=high && heap[j+1] >heap[j]){
            j=j+1;
        }
        //如果孩子中最大的权值比欲调整结点i大
        if(heap[j] > heap[i]){
            swap(heap[j], heap[i]);
            i=j;			//保持i为欲调整结点,j为i的左孩子
            j=i*2;
       }else{
            break;	//孩子的权值均比欲调整结点i小,调整结束
        }
    }
}
```

​	**建堆**,假设序列中元素的个数n,由于完全二叉树的叶子结点个数为n/2,因此数组下标在[1,n/2]范围内的结点都是非叶子结点.从n/2号位开始倒着枚举结点,.**保证每个结点都是以其为根结点的子树中的权值最大的结点**

```c++
//建堆
void createHeap(){
    for(int i=n/2;i>=1;i--){
        downAdjust(i,n);
    }
}
```

```C++
//删除堆顶元素
void deleteTop(){
    heap[1]=heap[n--];
    downAdjust(1,n);
}
```

```c++
//添加元素
//添加的元素放在数组,然后进行 向上调整,向上调整总是把欲调整结点与父亲结点比较,如果权值大,就交换其父亲结点,直到达堆顶或是父亲结点的权值较大为止.

//对heap数组在[low,high]范围进行向上调整
//其中low为一般设为1,high表示欲调整结点的数组下标
void upAdjust(int low,int high){
    int i=high,j=i/2;	//i为欲调整结点,j为父亲
    while(j>=low){		//父亲在[low,high]范围内
        //父亲权值小于欲调整结点i的权值
        if(heap[j] <heap[i]){
            swap(heap[j],heap[i]);
            i=j;
            j=i/2;
        }else{
            break;	
        }
    }
}

void insert(int x){
    heap[++n]=x;	//元素个数+1
    upAdjust(1,n);	//向上调整新加入的结点n
}
```



## 2. 堆排序

​	使用对结构堆一个序列进行排序.

​	取出堆顶元素,然后将堆的最后一个元素替换至堆顶,再进行一次针对堆顶元素的向下取整.直到堆中只有一个元素为止.

​	为了节省空间,可以**倒着遍历数组**,假设当前访问到i号位,那么将堆顶元素与i号位的元素交换,接着在[1~i-1]范围内对堆顶元素进行一次向下调整即可.

```c++
//堆排序
void heapSort(){
    createHeap();	//建堆
    for(int i=n;i>1;i--){		//倒着枚举,直到堆中只有一个元素
        swap(heap[i],heap[1]);	//交换heap[i]与堆顶
        downAdjust(1,i-1);		//调整堆顶
    }
}
```

### 





