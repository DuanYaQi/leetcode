# 贪心算法

贪心也没有什么框架和套路，所以对刷题顺序要求没有那么高。



1. 贪心很简单，就是常识？
贪心思路往往很**巧妙**，**但并不简单**。
2. 贪心有没有固定的套路？
贪心**无套路**，也没有框架之类的，需要多看**多练培养感觉**才能想到贪心的思路。
3. 究竟什么题目是贪心呢？
如果找出**局部最优并可以推出全局最优**，就是贪心，如果局部最优都没找出来，就不是贪心，可能是单纯的模拟。
4. 如何知道局部最优推出全局最优，有数学证明么？没有数学证明感觉不靠谱？
  手动模拟⼀下，如果找不出反例，就试试贪心。⾯试中，代码写出来跑过测试用例即可，或者自己能自圆其说理由就⾏了。



贪心的时候，既有简单**适当的证明**（反证法），也把常识性的知识**理论化，系统化**（局部最优、全局最优的分析）



---

## 关于贪心算法，你该了解这些！

拿到题先自己手动模拟，如果可行，试试贪心；如果不可行，动态规划。

如何验证可不可以用贪心算法呢？
最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。





### 贪心⼀般解题步骤

贪心算法⼀般分为如下四步：

​	将问题分解为若干个**子问题**
​	找出适合的贪心**策略**
​	求解每⼀个子问题的**局部最优解**
​	将局部最优解**堆叠**成**全局最优解**





## 455.分发饼干

为了了满足更多的小孩，就**不要造成饼干尺寸的浪费**。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

可以尝试使用贪心策略，先将饼干数组和小孩数组排序。

然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。

```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());

    int index = s.size() - 1;

    for (int i = g.size() - 1; i >= 0; --i) {
        if (index >= 0 &&  s[index] >= g[i]) {
            index--;
        }
    }

    return s.size() - 1 - index ;
}
```





---

## 376. 摆动序列

摆动序列



![image-20220309194323360](assets/image-20220309194323360.png)

**局部最优**：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。
**整体最优**：整个序列有最多的局部峰值，从而达到最⻓摆动序列。





实际操作上，其实连删除的操作都不用做，因为题⽬要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单⼀坡度上的节点，然后统计长度）



本题代码实现中，还有⼀些技巧，例如统计峰值的时候，数组最左和最右是最不好统计的。

例如序列[2,5]，它的峰值数量是2，如果靠统计差值来计算峰值个数就需要考虑数组最左和最右的特殊情况。所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 `preDiff = 0`，如图：

![image-20220309194555875](assets/image-20220309194555875.png)



针对以上情形，result 初始为1（默认最右有⼀个峰值），此时 `curDiff > 0 && preDiff <= 0`，那么 result++（计算了左面的峰值），最后得到的 result 就是2（峰值个数为2即摆动序列长度为2）



```c++
int wiggleMaxLength(vector<int>& nums) {
    int n = nums.size();
    int preDiff = 0;
    int curDiff = 0;
    int result = 1;

    for (int i = 1; i < n; ++i) {
        curDiff = nums[i] - nums[i-1];
        if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
            result++;
            preDiff = curDiff;
        }
    }

    return result;
}
```







---

## 53. 最大子序和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```



for 循环暴力输出

```c++
int maxSubArray(vector<int>& nums) {
    int result = INT_MIN;
    int tmp = 0;

    for (int i = 0; i < nums.size(); ++i) {
        tmp = nums[i];
        result = max(result, tmp);
        for (int j = i + 1; j < nums.size(); ++j) {
            tmp += nums[j];
            result = max(result, tmp);
        }
    }

    return result;
}
```







**贪心**

算开头，只要开头是负数，就可以直接不往后算了

局部最优：当前“连续和”为负数的时候立刻放弃，从下⼀个元素重新计算“连续和”，因为负数加上下⼀个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”





从代码角度上来讲：遍历nums，从头开始⽤count累积，如果count⼀旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。


```c++
int maxSubArray(vector<int>& nums) {
    int count = 0;
    int res = INT_MIN;

    for (int i = 0; i < nums.size(); ++i) {
        count += nums[i];
        res = max(res, count);
        if (count < 0) count = 0;
    }

    return res;
}
```

