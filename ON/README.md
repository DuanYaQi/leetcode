# 时间复杂度

https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6



https://mp.weixin.qq.com/s/I6ZXFbw09NR31F5CJR_geQ



**只跟他 i-1 和 j-1 有关的，都可以用滚动数组，直接计算完替换原来的值。**

**优化空间复杂度，其实就是找到需要几个值，就可以。不是所有值都需要保留**





---

## 6. Big O

目前分析算法主要从「**时间**」和「**空间**」两个维度来进行分析。时间维度顾名思义就是算法需要**消耗的时间**，「时间复杂度」是常用的分析单位。空间维度代表算法需要占用的**内存空间**，我们通常用「空间复杂度」来分析。

分析算法的效率主要从「**时间复杂度**」和「**空间复杂度**」来分析。这两个复杂度反映的是，随着问题量级的增大，时间和空间**增长的趋势**。很多时候我们两者不可兼得，有时候要用**时间换空间**，或者**空间换时间**。



---

### 6.1. 时间复杂度

`T(n)` 表示算法的**渐进时间复杂度**，`f(n)​` 表示代码**执行次数**，​`O()​` 表示**正比关系**。

```c++
for (int i = 1; i <= n; i++) {
    x++;
}

i <= n 	执行n+1次 最后还要再判断一次
i++		执行n次
x++;	执行n次
i = 1	执行1次
共3N+2次
```

`O(3N+2) = O(N)` 

关心的是**输入不断增长时程序的表现如何**，当N很大时，就是**最坏情况下的性能**，因此只需要**关注高阶项**，**忽略低阶项**。



```c++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
    	x++;
    }
}
```

时间复杂度为 `O(N^2)​`



```c++
for (int i = 1; i <= n; i++) {
    x++;
}
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
    	x++;
    }
}
```

时间复杂度为 `O(N+N^2)=O(N^2)​`



---

### 6.2. 常用时间复杂度量级

横轴为问题的量级，纵轴为时间复杂度

![37b5a1516b172f9c8456d1574a0446b5.png](assets/37b5a1516b172f9c8456d1574a0446b5.png)



![Image result for time complexity chart](assets/big-o-running-time-complexity.png)

- **常数**阶O(1)
- **对数**阶O(logN)



- **线性**阶O(n)
- **线性对数/超线性**阶O(nlogN)



- 平方阶O(n²)
- 立方阶O(n³)
- **K次方/多项式**阶O(n^k)
- **指数**阶(2^n)
- **阶乘**O(n!)



上面的时间复杂从上到下复杂度越来越大，也意味着执行效率越来越低。

![1616323325038](assets/1616323325038.png)



---

#### 6.2.1. 常数阶O(1)

只要没有**循环**或**递归**等复杂逻辑，无论代码执行多少行，代码复杂度都为O(1)，如下：

```c++
int x = 0;
int y = 1;
int temp = x;
x = y;
y = temp;
```

上述代码在执行的时候，所消耗的**时间不会随着特定变量的增长而增长**，即使有几万行这样的代码，我们都可以用O(1)来表示它的时间复杂度。



#### 6.2.2. 线性阶O(n)

```c++
for (int i = 1; i <= n; i++) {
    x++;
}
```

在这段代码中，for循环会执行n遍，因此**计算消耗的时间是随着n的变化而变化**，因此这类代码都可以用O(n)来表示其时间复杂度。



#### 6.2.3. 对数阶O(logN)

```c++
int i = 1;
while(i < n) {
    i = i * 2;
}
```

在上面的循环中，每次 i 都会被乘以2，也意味着每次 i 都离 n 更进一步。那需要多少次循环 i 才能等于或大于 n 呢，也就是求解 $2 ^ k = n$，答案 $k=log_{2}N$ 。 取最高次项，且去掉最高此项的系数，所有进一步简化为 $k=logN$

也就是说循环 $k=logN$ 次之后，i 会大于等于n，这段代码就结束了。所以此代码的复杂度为：`O(logN)`。



#### 6.2.4. 线性对数阶O(nlogN)

线性对数阶O(nlogN)很好理解，也就是将复杂度为O(logN)的代码循环n遍：

```c++
for(int i = 0; i <= n: i++) {
    int x = 1;
    while(x < n) {
        x = x * 2;
    }
}
```

因为每次循环的复杂度为 `O(logN)`，所以 `n * logN = O(nlogN)`



#### 6.2.5. 平方阶O(n²)

```c++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        x++;
    }
}

```

O(n²)的本质就是 `n * n`，如果我们将内层的循环次数改为m，复杂度就变为 `n * m = O(nm)`。

关于一些更高的阶级比如 `O(n³)` 或者 `O(n^k)`，我们可以参考 `O(n²)` 来理解即可，`O(n³)` 相当于三层循环，以此类推。



### 6.2.6. 指数阶O(2^n)

```c++
int f (int n) {
    if (n == 1) return 1;
    else return f(n-1) + f(n-1);
}
```

`O(2^N-1) = O(2^N)`

---



除了「大O表示法」还有其他「平均时间复杂度」、「均摊时间复杂度」、「最坏时间复杂度」、「最好时间复杂度」等等分析指数，但是最常用的依然是「大O表示法」，表示最差情况。



---

### 6.3. 空间复杂度

「空间复杂度」也不是用来计算程序具体占用的空间。随着问题量级的变大，程序需要分配的内存空间也可能会变得更多，而「空间复杂度」反映的则是**内存空间增长的趋势**。

比较常用的空间复杂度有：O(1)、O(n)、O(n²)。用 S(n) 来定义「空间复杂度」。



#### 6.3.1. O(1)空间复杂度

如果算法执行所需要的临时空间**不随着某个变量 n 的大小而变化**，此算法空间复杂度为一个**常量**，可表示为 O(1)：

```c++
int x = 0;
int y = 0;
x++;
y++;
```

其中x, y所分配的空间**不随着处理数据量变化**，因此「空间复杂度」为 O(1)



#### 6.3.2. O(n)空间复杂度

以下的代码给长度为n的数组赋值：

```c++
int[] newArray = new int[n];
for (int i = 0; i < n; i++) {
    newArray[i] = i;
}
```

在这段代码中，我们创建了一个长度为 n 的数组，然后在循环中为其中的元素赋值。因此，这段代码的「空间复杂度」**取决于 newArray 的长度**，也就是 n，所以 S(n) = O(n)。



如果newArray是个二维数组，则空间复杂度为O(n²)





![e85d4af103548c1f4d7729b6cf63607b.png](assets/e85d4af103548c1f4d7729b6cf63607b.png)



